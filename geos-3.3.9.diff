# Patch to fix building with Ruby 1.9 and PHP 5.4
#  * Ruby (fix compilation with Ruby 1.9)
#    - use RbConfig instead of Config
#    - use rubyhdrdir instead of archdir to get includes directory
#    - add site include directory
#    - fix of swig/ruby/geos_warp.cxx based on changeset 3518 by Kashif Rasul
#      see http://trac.osgeo.org/geos/changeset/3518
#  * PHP (fix compilation against thread-safe PHP)
#    - fix of php/geos.c based on changeset 4020 by strk
#      see http://trac.osgeo.org/geos/changeset/4020
# Copyright (C) 2015 Georgi D. Sotirov <gdsotirov@dir.bg>
#
# This program is free software; you can redistribute it and/or
# modify it under the terms of the GNU General Public License
# as published by the Free Software Foundation; either version 2
# of the License, or (at your option) any later version.
#
# This program is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU General Public License for more details.
#
# You should have received a copy of the GNU General Public License
# along with this program; if not, write to the Free Software
# Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA  02110-1301, USA.
#
diff --ignore-all-space -urNad geos-3.3.9-orig/macros/ruby.m4 geos-3.3.9/macros/ruby.m4
--- geos-3.3.9-orig/macros/ruby.m4	2007-09-07 02:22:38.000000000 +0300
+++ geos-3.3.9/macros/ruby.m4	2015-04-26 14:04:09.000000000 +0300
@@ -23,26 +23,30 @@
 		RUBY_VERSION=`$RUBY -e "puts RUBY_VERSION"`
 
 		dnl Get Ruby bin directory
-		RUBY_BIN_DIR=`$RUBY -rrbconfig -e 'puts Config::CONFIG[["bindir"]]'`
+		RUBY_BIN_DIR=`$RUBY -rrbconfig -e 'puts RbConfig::CONFIG[["bindir"]]'`
+
+		dnl Get Ruby site arch
+		RUBY_SITE_ARCH=`$RUBY -rrbconfig -e 'puts RbConfig::CONFIG[["sitearch"]]'`
 		
 		dnl Get Ruby include directory
-		RUBY_INCLUDE_DIR=`$RUBY -rrbconfig -e 'puts Config::CONFIG[["archdir"]]'`
+		RUBY_INCLUDE_DIR=`$RUBY -rrbconfig -e 'puts RbConfig::CONFIG[["rubyhdrdir"]]'`
 	
 		dnl Get Ruby lib directory
-		RUBY_LIB_DIR=`$RUBY -rrbconfig -e 'puts Config::CONFIG[["libdir"]]'`
+		RUBY_LIB_DIR=`$RUBY -rrbconfig -e 'puts RbConfig::CONFIG[["libdir"]]'`
 
 		dnl Get Ruby extensions directory
-		RUBY_EXTENSION_DIR=`$RUBY -rrbconfig -e 'puts Config::CONFIG[["sitearchdir"]]'`
+		RUBY_EXTENSION_DIR=`$RUBY -rrbconfig -e 'puts RbConfig::CONFIG[["sitearchdir"]]'`
 
 		dnl Get Ruby shared library name, this does not include the lib prefix or extension name
-		RUBY_SO_NAME=`$RUBY -rrbconfig -e 'puts Config::CONFIG[["RUBY_SO_NAME"]]'`
+		RUBY_SO_NAME=`$RUBY -rrbconfig -e 'puts RbConfig::CONFIG[["RUBY_SO_NAME"]]'`
 		
 		dnl Get Ruby shared libary name
-		RUBY_SHARED_LIB=`$RUBY -rrbconfig -e 'puts Config::CONFIG[["LIBRUBY"]]'`
+		RUBY_SHARED_LIB=`$RUBY -rrbconfig -e 'puts RbConfig::CONFIG[["LIBRUBY"]]'`
 		
     AC_MSG_NOTICE([Ruby executable is '$RUBY'])
     AC_MSG_NOTICE([Ruby version is '$RUBY_VERSION'])
     AC_MSG_NOTICE([Ruby bin directory is '$RUBY_BIN_DIR'])
+    AC_MSG_NOTICE([Ruby site arch is '$RUBY_SITE_ARCH'])
     AC_MSG_NOTICE([Ruby include directory is '$RUBY_INCLUDE_DIR'])
     AC_MSG_NOTICE([Ruby library directory is '$RUBY_LIB_DIR'])
     AC_MSG_NOTICE([Ruby extension directory is '$RUBY_EXTENSION_DIR'])
@@ -51,6 +55,7 @@
    
     AC_SUBST([RUBY_VERSION])
     AC_SUBST([RUBY_BIN_DIR])
+    AC_SUBST([RUBY_SITE_ARCH])
     AC_SUBST([RUBY_INCLUDE_DIR])
     AC_SUBST([RUBY_LIB_DIR])
     AC_SUBST([RUBY_EXTENSION_DIR])
diff --ignore-all-space -urNad geos-3.3.9-orig/php/geos.c geos-3.3.9/php/geos.c
--- geos-3.3.9-orig/php/geos.c	2012-05-09 19:28:02.000000000 +0300
+++ geos-3.3.9/php/geos.c	2014-09-24 10:54:58.000000000 +0300
@@ -78,6 +78,7 @@
 
 static void noticeHandler(const char *fmt, ...)
 {
+    TSRMLS_FETCH();
     char message[256];
     va_list args;
     va_start(args, fmt);
@@ -89,6 +90,7 @@
 
 static void errorHandler(const char *fmt, ...)
 {
+    TSRMLS_FETCH();
     char message[256];
     va_list args;
     va_start(args, fmt);
@@ -96,7 +98,7 @@
     va_end(args);
 
     /* TODO: use a GEOSException ? */
-    zend_throw_exception_ex(zend_exception_get_default(TSRMLS_CC),
+    zend_throw_exception_ex(zend_exception_get_default(TSRMLS_C),
         1 TSRMLS_CC, "%s", message); 
 
 }
@@ -108,12 +110,14 @@
 
 static void 
 setRelay(zval* val, void* obj) {
+    TSRMLS_FETCH();
     Proxy* proxy = (Proxy*)zend_object_store_get_object(val TSRMLS_CC);
     proxy->relay = obj;
 }
 
 static inline void *
 getRelay(zval* val, zend_class_entry* ce) {
+    TSRMLS_FETCH();
     Proxy *proxy =  (Proxy*)zend_object_store_get_object(val TSRMLS_CC);
     if ( proxy->std.ce != ce ) {
         php_error_docref(NULL TSRMLS_CC, E_ERROR,
@@ -153,9 +157,10 @@
 }
 
 static zend_object_value
-Gen_create_obj (zend_class_entry *type TSRMLS_DC,
+Gen_create_obj (zend_class_entry *type,
     zend_objects_free_object_storage_t st, zend_object_handlers* handlers)
 {
+    TSRMLS_FETCH();
     zval *tmp;
     zend_object_value retval;
 
@@ -407,6 +416,7 @@
 static void
 dumpGeometry(GEOSGeometry* g, zval* array)
 {
+    TSRMLS_FETCH();
     int ngeoms, i;
 
     /*
diff --ignore-all-space -urNad geos-3.3.9-orig/swig/ruby/Makefile.am geos-3.3.9/swig/ruby/Makefile.am
--- geos-3.3.9-orig/swig/ruby/Makefile.am	2010-01-13 05:03:38.000000000 +0200
+++ geos-3.3.9/swig/ruby/Makefile.am	2015-04-26 12:34:10.000000000 +0300
@@ -18,7 +18,7 @@
 rubyextensiondirdir = $(RUBY_EXTENSION_DIR)
 
 # Setup includes
-INCLUDES = -I$(RUBY_INCLUDE_DIR)
+INCLUDES = -I$(RUBY_INCLUDE_DIR) -I$(RUBY_INCLUDE_DIR)/$(RUBY_SITE_ARCH)
 
 # Build Ruby module as shared library
 rubyextensiondir_LTLIBRARIES = geos.la
diff --ignore-all-space -urNad geos-3.3.9-orig/swig/ruby/Makefile.in geos-3.3.9/swig/ruby/Makefile.in
--- geos-3.3.9-orig/swig/ruby/Makefile.in	2013-09-05 00:14:43.000000000 +0300
+++ geos-3.3.9/swig/ruby/Makefile.in	2015-04-26 13:37:02.000000000 +0300
@@ -239,6 +239,7 @@
 RANLIB = @RANLIB@
 RUBY = @RUBY@
 RUBY_BIN_DIR = @RUBY_BIN_DIR@
+RUBY_SITE_ARCH = @RUBY_SITE_ARCH@
 RUBY_EXTENSION_DIR = @RUBY_EXTENSION_DIR@
 RUBY_INCLUDE_DIR = @RUBY_INCLUDE_DIR@
 RUBY_LIB_DIR = @RUBY_LIB_DIR@
@@ -336,7 +337,7 @@
 @ENABLE_RUBY_TRUE@rubyextensiondirdir = $(RUBY_EXTENSION_DIR)
 
 # Setup includes
-@ENABLE_RUBY_TRUE@INCLUDES = -I$(RUBY_INCLUDE_DIR)
+@ENABLE_RUBY_TRUE@INCLUDES = -I$(RUBY_INCLUDE_DIR) -I$(RUBY_INCLUDE_DIR)/$(RUBY_SITE_ARCH)
 
 # Build Ruby module as shared library
 @ENABLE_RUBY_TRUE@rubyextensiondir_LTLIBRARIES = geos.la
diff --ignore-all-space -urNad geos-3.3.9-orig/swig/ruby/geos_wrap.cxx geos-3.3.9/swig/ruby/geos_wrap.cxx
--- geos-3.3.9-orig/swig/ruby/geos_wrap.cxx	2007-09-21 20:40:48.000000000 +0300
+++ geos-3.3.9/swig/ruby/geos_wrap.cxx	2011-11-25 00:07:19.000000000 +0200
@@ -1,6 +1,6 @@
 /* ----------------------------------------------------------------------------
  * This file was automatically generated by SWIG (http://www.swig.org).
- * Version 1.3.31
+ * Version 1.3.40
  * 
  * This file is not intended to be easily readable and contains a number of 
  * coding conventions designed to improve portability and efficiency. Do not make
@@ -10,20 +10,28 @@
 
 #define SWIGRUBY
 
+
 #ifdef __cplusplus
-template<class T> class SwigValueWrapper {
-    T *tt;
-public:
-    SwigValueWrapper() : tt(0) { }
-    SwigValueWrapper(const SwigValueWrapper<T>& rhs) : tt(new T(*rhs.tt)) { }
-    SwigValueWrapper(const T& t) : tt(new T(t)) { }
-    ~SwigValueWrapper() { delete tt; } 
-    SwigValueWrapper& operator=(const T& t) { delete tt; tt = new T(t); return *this; }
-    operator T&() const { return *tt; }
-    T *operator&() { return tt; }
-private:
+/* SwigValueWrapper is described in swig.swg */
+template<typename T> class SwigValueWrapper {
+  struct SwigMovePointer {
+    T *ptr;
+    SwigMovePointer(T *p) : ptr(p) { }
+    ~SwigMovePointer() { delete ptr; }
+    SwigMovePointer& operator=(SwigMovePointer& rhs) { T* oldptr = ptr; ptr = 0; delete oldptr; ptr = rhs.ptr; rhs.ptr = 0; return *this; }
+  } pointer;
     SwigValueWrapper& operator=(const SwigValueWrapper<T>& rhs);
+  SwigValueWrapper(const SwigValueWrapper<T>& rhs);
+public:
+  SwigValueWrapper() : pointer(0) { }
+  SwigValueWrapper& operator=(const T& t) { SwigMovePointer tmp(new T(t)); pointer = tmp; return *this; }
+  operator T&() const { return *pointer.ptr; }
+  T *operator&() { return pointer.ptr; }
 };
+
+template <typename T> T SwigValueInit() {
+  return T();
+}
 #endif
 
 /* -----------------------------------------------------------------------------
@@ -33,12 +41,12 @@
 
 /* template workaround for compilers that cannot correctly implement the C++ standard */
 #ifndef SWIGTEMPLATEDISAMBIGUATOR
-# if defined(__SUNPRO_CC)
-#   if (__SUNPRO_CC <= 0x560)
+# if defined(__SUNPRO_CC) && (__SUNPRO_CC <= 0x560)
+#  define SWIGTEMPLATEDISAMBIGUATOR template
+# elif defined(__HP_aCC)
+/* Needed even with `aCC -AA' when `aCC -V' reports HP ANSI C++ B3910B A.03.55 */
+/* If we find a maximum version that requires this, the test would be __HP_aCC <= 35500 for A.03.55 */
 #     define SWIGTEMPLATEDISAMBIGUATOR template
-#   else
-#     define SWIGTEMPLATEDISAMBIGUATOR 
-#   endif
 # else
 #   define SWIGTEMPLATEDISAMBIGUATOR 
 # endif
@@ -68,6 +76,12 @@
 # endif
 #endif
 
+#ifndef SWIG_MSC_UNSUPPRESS_4505
+# if defined(_MSC_VER)
+#   pragma warning(disable : 4505) /* unreferenced local function has been removed */
+# endif 
+#endif
+
 #ifndef SWIGUNUSEDPARM
 # ifdef __cplusplus
 #   define SWIGUNUSEDPARM(p)
@@ -123,6 +137,12 @@
 # define _CRT_SECURE_NO_DEPRECATE
 #endif
 
+/* Deal with Microsoft's attempt at deprecating methods in the standard C++ library */
+#if !defined(SWIG_NO_SCL_SECURE_NO_DEPRECATE) && defined(_MSC_VER) && !defined(_SCL_SECURE_NO_DEPRECATE)
+# define _SCL_SECURE_NO_DEPRECATE
+#endif
+
+
 /* -----------------------------------------------------------------------------
  *  This section contains generic SWIG labels for method/variable
  *  declarations/attributes, and other compiler dependent labels.
@@ -130,12 +150,12 @@
 
 /* template workaround for compilers that cannot correctly implement the C++ standard */
 #ifndef SWIGTEMPLATEDISAMBIGUATOR
-# if defined(__SUNPRO_CC)
-#   if (__SUNPRO_CC <= 0x560)
+# if defined(__SUNPRO_CC) && (__SUNPRO_CC <= 0x560)
+#  define SWIGTEMPLATEDISAMBIGUATOR template
+# elif defined(__HP_aCC)
+/* Needed even with `aCC -AA' when `aCC -V' reports HP ANSI C++ B3910B A.03.55 */
+/* If we find a maximum version that requires this, the test would be __HP_aCC <= 35500 for A.03.55 */
 #     define SWIGTEMPLATEDISAMBIGUATOR template
-#   else
-#     define SWIGTEMPLATEDISAMBIGUATOR 
-#   endif
 # else
 #   define SWIGTEMPLATEDISAMBIGUATOR 
 # endif
@@ -165,6 +185,12 @@
 # endif
 #endif
 
+#ifndef SWIG_MSC_UNSUPPRESS_4505
+# if defined(_MSC_VER)
+#   pragma warning(disable : 4505) /* unreferenced local function has been removed */
+# endif 
+#endif
+
 #ifndef SWIGUNUSEDPARM
 # ifdef __cplusplus
 #   define SWIGUNUSEDPARM(p)
@@ -220,6 +246,12 @@
 # define _CRT_SECURE_NO_DEPRECATE
 #endif
 
+/* Deal with Microsoft's attempt at deprecating methods in the standard C++ library */
+#if !defined(SWIG_NO_SCL_SECURE_NO_DEPRECATE) && defined(_MSC_VER) && !defined(_SCL_SECURE_NO_DEPRECATE)
+# define _SCL_SECURE_NO_DEPRECATE
+#endif
+
+
 /* -----------------------------------------------------------------------------
  * swigrun.swg
  *
@@ -229,7 +261,7 @@
 
 /* This should only be incremented when either the layout of swig_type_info changes,
    or for whatever reason, the runtime changes incompatibly */
-#define SWIG_RUNTIME_VERSION "3"
+#define SWIG_RUNTIME_VERSION "4"
 
 /* define SWIG_TYPE_TABLE_NAME as "SWIG_TYPE_TABLE" */
 #ifdef SWIG_TYPE_TABLE
@@ -242,11 +274,11 @@
 
 /*
   You can use the SWIGRUNTIME and SWIGRUNTIMEINLINE macros for
-  creating a static or dynamic library from the swig runtime code.
-  In 99.9% of the cases, swig just needs to declare them as 'static'.
+  creating a static or dynamic library from the SWIG runtime code.
+  In 99.9% of the cases, SWIG just needs to declare them as 'static'.
   
-  But only do this if is strictly necessary, ie, if you have problems
-  with your compiler or so.
+  But only do this if strictly necessary, ie, if you have problems
+  with your compiler or suchlike.
 */
 
 #ifndef SWIGRUNTIME
@@ -264,6 +296,7 @@
 
 /* Flags for pointer conversions */
 #define SWIG_POINTER_DISOWN        0x1
+#define SWIG_CAST_NEW_MEMORY       0x2
 
 /* Flags for new pointer objects */
 #define SWIG_POINTER_OWN           0x1
@@ -272,14 +305,14 @@
 /* 
    Flags/methods for returning states.
    
-   The swig conversion methods, as ConvertPtr, return and integer 
+   The SWIG conversion methods, as ConvertPtr, return and integer 
    that tells if the conversion was successful or not. And if not,
    an error code can be returned (see swigerrors.swg for the codes).
    
    Use the following macros/flags to set or process the returning
    states.
    
-   In old swig versions, you usually write code as:
+   In old versions of SWIG, code such as the following was usually written:
 
      if (SWIG_ConvertPtr(obj,vptr,ty.flags) != -1) {
        // success code
@@ -287,7 +320,7 @@
        //fail code
      }
 
-   Now you can be more explicit as:
+   Now you can be more explicit:
 
     int res = SWIG_ConvertPtr(obj,vptr,ty.flags);
     if (SWIG_IsOK(res)) {
@@ -296,7 +329,7 @@
       // fail code
     }
 
-   that seems to be the same, but now you can also do
+   which is the same really, but now you can also do
 
     Type *ptr;
     int res = SWIG_ConvertPtr(obj,(void **)(&ptr),ty.flags);
@@ -314,7 +347,7 @@
     
    I.e., now SWIG_ConvertPtr can return new objects and you can
    identify the case and take care of the deallocation. Of course that
-   requires also to SWIG_ConvertPtr to return new result values, as
+   also requires SWIG_ConvertPtr to return new result values, such as
 
       int SWIG_ConvertPtr(obj, ptr,...) {         
         if (<obj is ok>) {			       
@@ -332,7 +365,7 @@
 
    Of course, returning the plain '0(success)/-1(fail)' still works, but you can be
    more explicit by returning SWIG_BADOBJ, SWIG_ERROR or any of the
-   swig errors code.
+   SWIG errors code.
 
    Finally, if the SWIG_CASTRANK_MODE is enabled, the result code
    allows to return the 'cast rank', for example, if you have this
@@ -346,9 +379,8 @@
       fooi(1)   // cast rank '0'
 
    just use the SWIG_AddCast()/SWIG_CheckState()
-
-
  */
+
 #define SWIG_OK                    (0) 
 #define SWIG_ERROR                 (-1)
 #define SWIG_IsOK(r)               (r >= 0)
@@ -373,7 +405,6 @@
 #define SWIG_DelTmpMask(r)         (SWIG_IsOK(r) ? (r & ~SWIG_TMPOBJMASK) : r)
 #define SWIG_IsTmpObj(r)           (SWIG_IsOK(r) && (r & SWIG_TMPOBJMASK))
 
-
 /* Cast-Rank Mode */
 #if defined(SWIG_CASTRANK_MODE)
 #  ifndef SWIG_TypeRank
@@ -396,18 +427,16 @@
 #endif
 
 
-
-
 #include <string.h>
 
 #ifdef __cplusplus
 extern "C" {
 #endif
 
-typedef void *(*swig_converter_func)(void *);
+typedef void *(*swig_converter_func)(void *, int *);
 typedef struct swig_type_info *(*swig_dycast_func)(void **);
 
-/* Structure to store inforomation on one type */
+/* Structure to store information on one type */
 typedef struct swig_type_info {
   const char             *name;			/* mangled name of this type */
   const char             *str;			/* human readable name of this type */
@@ -452,7 +481,7 @@
     while ((*f2 == ' ') && (f2 != l2)) ++f2;
     if (*f1 != *f2) return (*f1 > *f2) ? 1 : -1;
   }
-  return (l1 - f1) - (l2 - f2);
+  return (int)((l1 - f1) - (l2 - f2));
 }
 
 /*
@@ -494,48 +523,66 @@
 }
 
 
-/* think of this as a c++ template<> or a scheme macro */
-#define SWIG_TypeCheck_Template(comparison, ty)         \
-  if (ty) {                                             \
-    swig_cast_info *iter = ty->cast;                    \
-    while (iter) {                                      \
-      if (comparison) {                                 \
-        if (iter == ty->cast) return iter;              \
-        /* Move iter to the top of the linked list */   \
-        iter->prev->next = iter->next;                  \
-        if (iter->next)                                 \
-          iter->next->prev = iter->prev;                \
-        iter->next = ty->cast;                          \
-        iter->prev = 0;                                 \
-        if (ty->cast) ty->cast->prev = iter;            \
-        ty->cast = iter;                                \
-        return iter;                                    \
-      }                                                 \
-      iter = iter->next;                                \
-    }                                                   \
-  }                                                     \
-  return 0
-
 /*
   Check the typename
 */
 SWIGRUNTIME swig_cast_info *
 SWIG_TypeCheck(const char *c, swig_type_info *ty) {
-  SWIG_TypeCheck_Template(strcmp(iter->type->name, c) == 0, ty);
+  if (ty) {
+    swig_cast_info *iter = ty->cast;
+    while (iter) {
+      if (strcmp(iter->type->name, c) == 0) {
+        if (iter == ty->cast)
+          return iter;
+        /* Move iter to the top of the linked list */
+        iter->prev->next = iter->next;
+        if (iter->next)
+          iter->next->prev = iter->prev;
+        iter->next = ty->cast;
+        iter->prev = 0;
+        if (ty->cast) ty->cast->prev = iter;
+        ty->cast = iter;
+        return iter;
+      }
+      iter = iter->next;
+    }
+  }
+  return 0;
 }
 
-/* Same as previous function, except strcmp is replaced with a pointer comparison */
+/* 
+  Identical to SWIG_TypeCheck, except strcmp is replaced with a pointer comparison
+*/
 SWIGRUNTIME swig_cast_info *
-SWIG_TypeCheckStruct(swig_type_info *from, swig_type_info *into) {
-  SWIG_TypeCheck_Template(iter->type == from, into);
+SWIG_TypeCheckStruct(swig_type_info *from, swig_type_info *ty) {
+  if (ty) {
+    swig_cast_info *iter = ty->cast;
+    while (iter) {
+      if (iter->type == from) {
+        if (iter == ty->cast)
+          return iter;
+        /* Move iter to the top of the linked list */
+        iter->prev->next = iter->next;
+        if (iter->next)
+          iter->next->prev = iter->prev;
+        iter->next = ty->cast;
+        iter->prev = 0;
+        if (ty->cast) ty->cast->prev = iter;
+        ty->cast = iter;
+        return iter;
+      }
+      iter = iter->next;
+    }
+  }
+  return 0;
 }
 
 /*
   Cast a pointer up an inheritance hierarchy
 */
 SWIGRUNTIMEINLINE void *
-SWIG_TypeCast(swig_cast_info *ty, void *ptr) {
-  return ((!ty) || (!ty->converter)) ? ptr : (*ty->converter)(ptr);
+SWIG_TypeCast(swig_cast_info *ty, void *ptr, int *newmemory) {
+  return ((!ty) || (!ty->converter)) ? ptr : (*ty->converter)(ptr, newmemory);
 }
 
 /* 
@@ -808,6 +855,24 @@
 
 #include <ruby.h>
 
+/* Remove global macros defined in Ruby's win32.h */
+#ifdef write
+# undef write
+#endif
+#ifdef read
+# undef read
+#endif
+#ifdef bind
+# undef bind
+#endif
+#ifdef close
+# undef close
+#endif
+#ifdef connect
+# undef connect
+#endif
+
+
 /* Ruby 1.7 defines NUM2LL(), LL2NUM() and ULL2NUM() macros */
 #ifndef NUM2LL
 #define NUM2LL(x) NUM2LONG((x))
@@ -836,12 +901,44 @@
 #ifndef RSTRING_PTR
 # define RSTRING_PTR(x) RSTRING(x)->ptr
 #endif
+#ifndef RSTRING_END
+# define RSTRING_END(x) (RSTRING_PTR(x) + RSTRING_LEN(x))
+#endif
 #ifndef RARRAY_LEN
 # define RARRAY_LEN(x) RARRAY(x)->len
 #endif
 #ifndef RARRAY_PTR
 # define RARRAY_PTR(x) RARRAY(x)->ptr
 #endif
+#ifndef RFLOAT_VALUE
+# define RFLOAT_VALUE(x) RFLOAT(x)->value
+#endif
+#ifndef DOUBLE2NUM
+# define DOUBLE2NUM(x) rb_float_new(x)
+#endif
+#ifndef RHASH_TBL
+# define RHASH_TBL(x) (RHASH(x)->tbl)
+#endif
+#ifndef RHASH_ITER_LEV
+# define RHASH_ITER_LEV(x) (RHASH(x)->iter_lev)
+#endif
+#ifndef RHASH_IFNONE
+# define RHASH_IFNONE(x) (RHASH(x)->ifnone)
+#endif
+#ifndef RHASH_SIZE
+# define RHASH_SIZE(x) (RHASH(x)->tbl->num_entries)
+#endif
+#ifndef RHASH_EMPTY_P
+# define RHASH_EMPTY_P(x) (RHASH_SIZE(x) == 0)
+#endif
+#ifndef RSTRUCT_LEN
+# define RSTRUCT_LEN(x) RSTRUCT(x)->len
+#endif
+#ifndef RSTRUCT_PTR
+# define RSTRUCT_PTR(x) RSTRUCT(x)->ptr
+#endif
+
+
 
 /*
  * Need to be very careful about how these macros are defined, especially
@@ -903,6 +1000,7 @@
 #define rb_undef_alloc_func(klass) rb_undef_method(CLASS_OF((klass)), "new")
 #endif
 
+static VALUE _mSWIG = Qnil;
 
 /* -----------------------------------------------------------------------------
  * error manipulation
@@ -993,7 +1091,71 @@
 }
 
 
+/* This function is called when a user inputs a wrong argument to
+   a method.
+ */
+SWIGINTERN 
+const char* Ruby_Format_TypeError( const char* msg,
+				   const char* type, 
+				   const char* name, 
+				   const int argn,
+				   VALUE input )
+{
+  char buf[128];
+  VALUE str;
+  VALUE asStr;
+  if ( msg && *msg )
+    {
+      str = rb_str_new2(msg);
+    }
+  else
+    {
+      str = rb_str_new(NULL, 0);
+    }
+
+  str = rb_str_cat2( str, "Expected argument " );
+  sprintf( buf, "%d of type ", argn-1 );
+  str = rb_str_cat2( str, buf );
+  str = rb_str_cat2( str, type );
+  str = rb_str_cat2( str, ", but got " );
+  str = rb_str_cat2( str, rb_obj_classname(input) );
+  str = rb_str_cat2( str, " " );
+  asStr = rb_inspect(input);
+  if ( RSTRING_LEN(asStr) > 30 )
+    {
+      str = rb_str_cat( str, StringValuePtr(asStr), 30 );
+      str = rb_str_cat2( str, "..." );
+    }
+  else
+    {
+      str = rb_str_append( str, asStr );
+    }
+
+  if ( name )
+    {
+      str = rb_str_cat2( str, "\n\tin SWIG method '" );
+      str = rb_str_cat2( str, name );
+      str = rb_str_cat2( str, "'" );
+    }
 
+  return StringValuePtr( str );
+}
+
+/* This function is called when an overloaded method fails */
+SWIGINTERN 
+void Ruby_Format_OverloadedError(
+				 const int argc,
+				 const int maxargs,
+				 const char* method, 
+				 const char* prototypes 
+				 )
+{
+  const char* msg = "Wrong # of arguments";
+  if ( argc <= maxargs ) msg = "Wrong arguments";
+  rb_raise(rb_eArgError,"%s for overloaded method '%s'.\n"  
+	   "Possible C/C++ prototypes are:\n%s",
+	   msg, method, prototypes);
+}
 
 /* -----------------------------------------------------------------------------
  * See the LICENSE file for information on copyright, usage and redistribution
@@ -1011,22 +1173,50 @@
 extern "C" {
 #endif
 
+/* Ruby 1.8 actually assumes the first case. */
+#if SIZEOF_VOIDP == SIZEOF_LONG
+#  define SWIG2NUM(v) LONG2NUM((unsigned long)v)
+#  define NUM2SWIG(x) (unsigned long)NUM2LONG(x)
+#elif SIZEOF_VOIDP == SIZEOF_LONG_LONG
+#  define SWIG2NUM(v) LL2NUM((unsigned long long)v)
+#  define NUM2SWIG(x) (unsigned long long)NUM2LL(x)
+#else
+#  error sizeof(void*) is not the same as long or long long
+#endif
+
 
 /* Global Ruby hash table to store Trackings from C/C++
-   structs to Ruby Objects. */
-static VALUE swig_ruby_trackings;
+   structs to Ruby Objects. 
+*/
+static VALUE swig_ruby_trackings = Qnil;
 
 /* Global variable that stores a reference to the ruby
    hash table delete function. */
-static ID swig_ruby_hash_delete = 0;
+static ID swig_ruby_hash_delete;
 
 /* Setup a Ruby hash table to store Trackings */
 SWIGRUNTIME void SWIG_RubyInitializeTrackings(void) {
   /* Create a ruby hash table to store Trackings from C++ 
-     objects to Ruby objects.  Also make sure to tell
-     the garabage collector about the hash table. */
+     objects to Ruby objects. */
+
+  /* Try to see if some other .so has already created a 
+     tracking hash table, which we keep hidden in an instance var
+     in the SWIG module.
+     This is done to allow multiple DSOs to share the same
+     tracking table.
+  */
+  ID trackings_id = rb_intern( "@__trackings__" );
+  VALUE verbose = rb_gv_get("VERBOSE");
+  rb_gv_set("VERBOSE", Qfalse);
+  swig_ruby_trackings = rb_ivar_get( _mSWIG, trackings_id );
+  rb_gv_set("VERBOSE", verbose);
+
+  /* No, it hasn't.  Create one ourselves */ 
+  if ( swig_ruby_trackings == Qnil )
+    {
   swig_ruby_trackings = rb_hash_new();
-  rb_gc_register_address(&swig_ruby_trackings);
+      rb_ivar_set( _mSWIG, trackings_id, swig_ruby_trackings );
+    }
   
   /* Now store a reference to the hash table delete function
      so that we only have to look it up once.*/
@@ -1040,8 +1230,7 @@
      a Ruby number object. */
 
   /* Convert the pointer to a Ruby number */
-  unsigned long value = (unsigned long) ptr;
-  return LONG2NUM(value);
+  return SWIG2NUM(ptr);
 }
 
 /* Get a Ruby number to reference an object */
@@ -1051,8 +1240,7 @@
      a Ruby number object. */
 
   /* Convert the Object to a Ruby number */
-  unsigned long value = (unsigned long) object;
-  return LONG2NUM(value);
+  return SWIG2NUM(object);
 }
 
 /* Get a Ruby object from a previously stored reference */
@@ -1060,9 +1248,8 @@
   /* The provided Ruby number object is a reference
      to the Ruby object we want.*/
 
-  /* First convert the Ruby number to a C number */
-  unsigned long value = NUM2LONG(reference);
-  return (VALUE) value;
+  /* Convert the Ruby number to a Ruby object */
+  return NUM2SWIG(reference);
 }
 
 /* Add a Tracking from a C/C++ struct to a Ruby object */
@@ -1154,6 +1341,15 @@
   return target;
 }
 
+/* For ruby1.8.4 and earlier. */
+#ifndef RUBY_INIT_STACK
+   RUBY_EXTERN void Init_stack(VALUE* addr);
+#  define RUBY_INIT_STACK \
+   VALUE variable_in_this_stack_frame; \
+   Init_stack(&variable_in_this_stack_frame);
+#endif
+
+
 #ifdef __cplusplus
 }
 #endif
@@ -1218,6 +1414,7 @@
 #define SWIG_MangleStr(value)                        	SWIG_Ruby_MangleStr(value)		  
 #define SWIG_CheckConvert(value, ty)                 	SWIG_Ruby_CheckConvert(value, ty)	  
 
+#include "assert.h"
 
 /* -----------------------------------------------------------------------------
  * pointers/data manipulation
@@ -1225,9 +1422,6 @@
 
 #ifdef __cplusplus
 extern "C" {
-#if 0
-} /* cc-mode */
-#endif
 #endif
 
 typedef struct {
@@ -1239,10 +1433,44 @@
 } swig_class;
 
 
-static VALUE _mSWIG = Qnil;
+/* Global pointer used to keep some internal SWIG stuff */
 static VALUE _cSWIG_Pointer = Qnil;
 static VALUE swig_runtime_data_type_pointer = Qnil;
 
+/* Global IDs used to keep some internal SWIG stuff */
+static ID swig_arity_id = 0;
+static ID swig_call_id  = 0;
+
+/*
+  If your swig extension is to be run within an embedded ruby and has
+  director callbacks, you should set -DRUBY_EMBEDDED during compilation.  
+  This will reset ruby's stack frame on each entry point from the main 
+  program the first time a virtual director function is invoked (in a 
+  non-recursive way).
+  If this is not done, you run the risk of Ruby trashing the stack.
+*/
+
+#ifdef RUBY_EMBEDDED
+
+#  define SWIG_INIT_STACK                            \
+      if ( !swig_virtual_calls ) { RUBY_INIT_STACK } \
+      ++swig_virtual_calls;
+#  define SWIG_RELEASE_STACK --swig_virtual_calls;
+#  define Ruby_DirectorTypeMismatchException(x) \
+          rb_raise( rb_eTypeError, x ); return c_result;
+
+      static unsigned int swig_virtual_calls = 0;
+
+#else  /* normal non-embedded extension */
+
+#  define SWIG_INIT_STACK
+#  define SWIG_RELEASE_STACK
+#  define Ruby_DirectorTypeMismatchException(x) \
+          throw Swig::DirectorTypeMismatchException( x );
+
+#endif  /* RUBY_EMBEDDED */
+
+
 SWIGRUNTIME VALUE 
 getExceptionClass(void) {
   static int init = 0;
@@ -1274,6 +1502,8 @@
 {
   if (_mSWIG == Qnil) {
     _mSWIG = rb_define_module("SWIG");
+    swig_call_id  = rb_intern("call");
+    swig_arity_id = rb_intern("arity");
   }
 }
 
@@ -1297,7 +1527,7 @@
 SWIG_Ruby_NewPointerObj(void *ptr, swig_type_info *type, int flags)
 {
   int own =  flags & SWIG_POINTER_OWN; 
-  
+  int track;
   char *klass_name;
   swig_class *sklass;
   VALUE klass;
@@ -1310,14 +1540,15 @@
     sklass = (swig_class *) type->clientdata;
 		
     /* Are we tracking this class and have we already returned this Ruby object? */
-    if (sklass->trackObjects) {
+    track = sklass->trackObjects;
+    if (track) {
       obj = SWIG_RubyInstanceFor(ptr);
       
       /* Check the object's type and make sure it has the correct type.
         It might not in cases where methods do things like 
         downcast methods. */
       if (obj != Qnil) {
-        VALUE value = rb_iv_get(obj, "__swigtype__");
+        VALUE value = rb_iv_get(obj, "@__swigtype__");
         char* type_name = RSTRING_PTR(value);
 				
         if (strcmp(type->name, type_name) == 0) {
@@ -1327,10 +1558,13 @@
     }
 
     /* Create a new Ruby object */
-    obj = Data_Wrap_Struct(sklass->klass, VOIDFUNC(sklass->mark), (own ? VOIDFUNC(sklass->destroy) : 0), ptr);
+    obj = Data_Wrap_Struct(sklass->klass, VOIDFUNC(sklass->mark), 
+			   ( own ? VOIDFUNC(sklass->destroy) : 
+			     (track ? VOIDFUNC(SWIG_RubyRemoveTracking) : 0 )
+			     ), ptr);
 
     /* If tracking is on for this class then track this object. */
-    if (sklass->trackObjects) {
+    if (track) {
       SWIG_RubyAddTracking(ptr, obj);
     }
   } else {
@@ -1340,7 +1574,7 @@
     free((void *) klass_name);
     obj = Data_Wrap_Struct(klass, 0, 0, ptr);
   }
-  rb_iv_set(obj, "__swigtype__", rb_str_new2(type->name));
+  rb_iv_set(obj, "@__swigtype__", rb_str_new2(type->name));
   
   return obj;
 }
@@ -1352,7 +1586,7 @@
   VALUE obj;
   swig_class *sklass = (swig_class *) type->clientdata;
   obj = Data_Wrap_Struct(klass, VOIDFUNC(sklass->mark), VOIDFUNC(sklass->destroy), 0);
-  rb_iv_set(obj, "__swigtype__", rb_str_new2(type->name));
+  rb_iv_set(obj, "@__swigtype__", rb_str_new2(type->name));
   return obj;
 }
 
@@ -1360,7 +1594,7 @@
 SWIGRUNTIMEINLINE char *
 SWIG_Ruby_MangleStr(VALUE obj)
 {
-  VALUE stype = rb_iv_get(obj, "__swigtype__");
+  VALUE stype = rb_iv_get(obj, "@__swigtype__");
   return StringValuePtr(stype);
 }
 
@@ -1442,8 +1676,11 @@
     tc = SWIG_TypeCheck(c, ty);
     if (!tc) {
       return SWIG_ERROR;
+    } else {
+      int newmemory = 0;
+      *ptr = SWIG_TypeCast(tc, vptr, &newmemory);
+      assert(!newmemory); /* newmemory handling not yet implemented */
     }
-    *ptr = SWIG_TypeCast(tc, vptr);
   } else {
     *ptr = vptr;
   }
@@ -1524,10 +1761,42 @@
   rb_define_readonly_variable("$swig_runtime_data_type_pointer" SWIG_RUNTIME_VERSION SWIG_TYPE_TABLE_NAME, &swig_runtime_data_type_pointer);
 }
 
+/* This function can be used to check whether a proc or method or similarly
+   callable function has been passed.  Usually used in a %typecheck, like:
+
+   %typecheck(c_callback_t, precedence=SWIG_TYPECHECK_POINTER) {
+        $result = SWIG_Ruby_isCallable( $input );
+   }
+ */
+SWIGINTERN
+int SWIG_Ruby_isCallable( VALUE proc )
+{
+  if ( rb_respond_to( proc, swig_call_id ) == Qtrue )
+    return 1;
+  return 0;
+}
+
+/* This function can be used to check the arity (number of arguments)
+   a proc or method can take.  Usually used in a %typecheck.
+   Valid arities will be that equal to minimal or those < 0
+   which indicate a variable number of parameters at the end.
+ */
+SWIGINTERN
+int SWIG_Ruby_arity( VALUE proc, int minimal )
+{
+  if ( rb_respond_to( proc, swig_arity_id ) == Qtrue )
+    {
+      VALUE num = rb_funcall( proc, swig_arity_id, 0 );
+      int arity = NUM2INT(num);
+      if ( arity < 0 && (arity+1) < -minimal ) return 1;
+      if ( arity == minimal ) return 1;
+      return 1;
+    }
+  return 0;
+}
+
+
 #ifdef __cplusplus
-#if 0
-{ /* cc-mode */
-#endif
 }
 #endif
 
@@ -1555,16 +1824,22 @@
 #define SWIGTYPE_p_GeosMultiPolygon swig_types[8]
 #define SWIGTYPE_p_GeosPoint swig_types[9]
 #define SWIGTYPE_p_GeosPolygon swig_types[10]
-#define SWIGTYPE_p_GeosWkbReader swig_types[11]
-#define SWIGTYPE_p_GeosWkbWriter swig_types[12]
-#define SWIGTYPE_p_GeosWktReader swig_types[13]
-#define SWIGTYPE_p_GeosWktWriter swig_types[14]
-#define SWIGTYPE_p_char swig_types[15]
-#define SWIGTYPE_p_p_GeosLinearRing swig_types[16]
-#define SWIGTYPE_p_size_t swig_types[17]
-#define SWIGTYPE_p_unsigned_char swig_types[18]
-static swig_type_info *swig_types[20];
-static swig_module_info swig_module = {swig_types, 19, 0, 0, 0, 0};
+#define SWIGTYPE_p_GeosPreparedGeometry swig_types[11]
+#define SWIGTYPE_p_GeosSTRtree swig_types[12]
+#define SWIGTYPE_p_GeosWkbReader swig_types[13]
+#define SWIGTYPE_p_GeosWkbWriter swig_types[14]
+#define SWIGTYPE_p_GeosWktReader swig_types[15]
+#define SWIGTYPE_p_GeosWktWriter swig_types[16]
+#define SWIGTYPE_p_char swig_types[17]
+#define SWIGTYPE_p_p_GeosLinearRing swig_types[18]
+#define SWIGTYPE_p_p_void swig_types[19]
+#define SWIGTYPE_p_size_t swig_types[20]
+#define SWIGTYPE_p_swig__ConstIterator swig_types[21]
+#define SWIGTYPE_p_swig__GC_VALUE swig_types[22]
+#define SWIGTYPE_p_swig__Iterator swig_types[23]
+#define SWIGTYPE_p_unsigned_char swig_types[24]
+static swig_type_info *swig_types[26];
+static swig_module_info swig_module = {swig_types, 25, 0, 0, 0, 0};
 #define SWIG_TypeQuery(name) SWIG_TypeQueryModule(&swig_module, &swig_module, name)
 #define SWIG_MangledTypeQuery(name) SWIG_MangledTypeQueryModule(&swig_module, &swig_module, name)
 
@@ -1575,7 +1850,11 @@
 
 static VALUE mGeos;
 
-#define SWIGVERSION 0x010331 
+#define SWIG_RUBY_THREAD_BEGIN_BLOCK
+#define SWIG_RUBY_THREAD_END_BLOCK
+
+
+#define SWIGVERSION 0x010340 
 #define SWIG_VERSION SWIGVERSION
 
 
@@ -1589,56 +1868,645 @@
 #include <string>
 
 
+#include <iostream>
+
+
 #include <stdexcept>
 
 
-#include <string>
+namespace swig {
+  class GC_VALUE {
+  protected:
+    // Hash of all GC_VALUE's currently in use
+    static VALUE _hash;
 
-#define SWIG_FLOAT_P(x) ((TYPE(x) == T_FLOAT) || FIXNUM_P(x))
+    VALUE  _obj;
 
-bool SWIG_BOOL_P(VALUE) {
-    // dummy test, RTEST should take care of everything
-    return true;
+    static ID hash_id;
+    static ID   lt_id;
+    static ID   gt_id;
+    static ID   eq_id;
+    static ID   le_id;
+    static ID   ge_id;
+
+    static ID  pos_id;
+    static ID  neg_id;
+    static ID  inv_id;
+
+    static ID  add_id;
+    static ID  sub_id;
+    static ID  mul_id;
+    static ID  div_id;
+    static ID  mod_id;
+
+    static ID  and_id;
+    static ID   or_id;
+    static ID  xor_id;
+
+    static ID  lshift_id;
+    static ID  rshift_id;
+
+    struct OpArgs
+    {
+      VALUE src;
+      ID    id;
+      int   nargs;
+      VALUE target;
+    };
+
+
+  public:
+    static void initialize()
+    {
+      if ( _hash == Qnil ) 
+	{ 
+	  _hash = rb_hash_new();
+	  rb_gc_register_address( &_hash );
 }
-bool SWIG_RB2BOOL(VALUE x) {
-    return RTEST(x);
 }
-VALUE SWIG_BOOL2RB(bool b) {
-    return b ? Qtrue : Qfalse;
+
+    // this function is never called.  Provided for symmetry only.
+    static void cleanup()
+    {
+      rb_gc_unregister_address( &_hash );
 }
-double SWIG_NUM2DBL(VALUE x) {
-    return (FIXNUM_P(x) ? FIX2INT(x) : NUM2DBL(x));
+
+    GC_VALUE() : _obj( Qnil )
+    {
 }
-bool SWIG_STRING_P(VALUE x) {
-    return TYPE(x) == T_STRING;
+
+    GC_VALUE(const GC_VALUE& item) : _obj(item._obj)
+    {
+      GC_register();
 }
-std::string SWIG_RB2STR(VALUE x) {
-    return std::string(RSTRING_PTR(x), RSTRING_LEN(x));
+    
+    GC_VALUE(VALUE obj) :_obj(obj)
+    {
+      GC_register();
 }
-VALUE SWIG_STR2RB(const std::string& s) {
-    return rb_str_new(s.data(), s.size());
+    
+    ~GC_VALUE() 
+    {
+      GC_unregister();
 }
 
+    GC_VALUE & operator=(const GC_VALUE& item) 
+    {
+      GC_unregister();
+      _obj = item._obj;
+      GC_register();
+      return *this;
+    }
 
-#include <vector>
-#include <algorithm>
+    void GC_register()
+    {
+      if ( FIXNUM_P(_obj) || SPECIAL_CONST_P(_obj) || SYMBOL_P(_obj) ) 
+	return;
+      VALUE val = rb_hash_aref( _hash, _obj );
+      unsigned n = FIXNUM_P(val) ? NUM2UINT(val) : 0;
+      ++n;
+      rb_hash_aset( _hash, _obj, INT2NUM(n) );
+    }
+
+    void GC_unregister()
+    {
+      if ( FIXNUM_P(_obj) || SPECIAL_CONST_P(_obj) || SYMBOL_P(_obj) ) 
+	return;
+      // this test should not be needed but I've noticed some very erratic
+      // behavior of none being unregistered in some very rare situations.
+      if ( BUILTIN_TYPE(_obj) == T_NONE ) return;
+
+      VALUE val = rb_hash_aref( _hash, _obj );
+      unsigned n = FIXNUM_P(val) ? NUM2UINT(val) : 1;
+      --n;
+      if ( n )
+	rb_hash_aset( _hash, _obj, INT2NUM(n) );
+      else
+	rb_hash_delete( _hash, _obj );
+    }
+    
+    operator VALUE() const
+    {
+      return _obj;
+    }
+
+    VALUE inspect() const
+    {
+      return rb_inspect(_obj);
+    }
+
+    VALUE to_s() const
+    {
+      return rb_inspect(_obj);
+    }
+
+    static VALUE swig_protect_funcall( VALUE p )
+    {
+      OpArgs* args = (OpArgs*) p;
+      return rb_funcall( args->src, args->id, args->nargs, args->target );
+    }
+
+
+#define GC_VALUE_CMP( op_id, op, cmp, cmpval ) \
+    bool op( const GC_VALUE& other ) const \
+    { \
+      if ( FIXNUM_P(_obj) && FIXNUM_P(other._obj) ) \
+      { \
+	return _obj cmp other._obj; \
+      } \
+      bool  res = false; \
+      VALUE ret = Qnil; \
+      SWIG_RUBY_THREAD_BEGIN_BLOCK; \
+      if ( rb_respond_to( _obj, op_id ) == Qtrue ) \
+	{ \
+	  int status; \
+	  OpArgs  args; \
+          args.src    = _obj; \
+	  args.id     = op_id; \
+	  args.nargs  = 1; \
+	  args.target = VALUE(other); \
+	  ret = rb_protect( PROTECTFUNC(swig_protect_funcall), \
+                            VALUE(&args), &status ); \
+	} \
+      if ( ret == Qnil ) { \
+	VALUE a = rb_funcall(         _obj, hash_id, 0 ); \
+	VALUE b = rb_funcall( VALUE(other), hash_id, 0 ); \
+	res = a cmp b; \
+      } \
+      else \
+	{ \
+	  res = RTEST( ret ); \
+	} \
+      SWIG_RUBY_THREAD_END_BLOCK; \
+      return res; \
+    }
+
+
+    GC_VALUE_CMP( eq_id, operator==, ==, == 0 )
+    GC_VALUE_CMP( lt_id, operator<,  < , <  0 )
+    GC_VALUE_CMP( le_id, operator<=, <=, <= 0 )
+    GC_VALUE_CMP( gt_id, operator>,  > , >  0 )
+    GC_VALUE_CMP( ge_id, operator>=, >=, >= 0 )
+#undef GC_VALUE_CMP
+
+    bool operator!=( const GC_VALUE& other )
+    {
+      return !(this->operator==(other));
+    }
+
+#define GC_VALUE_UNARY( proc_id, op ) \
+    GC_VALUE op() const \
+    { \
+      VALUE ret = Qnil; \
+      SWIG_RUBY_THREAD_BEGIN_BLOCK; \
+      int status; \
+      OpArgs  args; \
+      args.src    = _obj; \
+      args.id     = proc_id; \
+      args.nargs  = 0; \
+      args.target = Qnil; \
+      ret = rb_protect( PROTECTFUNC(swig_protect_funcall), VALUE(&args), \
+			&status ); \
+      SWIG_RUBY_THREAD_END_BLOCK; \
+      return ret; \
+    }
+
+    GC_VALUE_UNARY( pos_id, operator+ )
+    GC_VALUE_UNARY( neg_id, operator- )
+    GC_VALUE_UNARY( inv_id, operator~ )
+#undef GC_VALUE_BINARY
+
+#define GC_VALUE_BINARY( proc_id, op ) \
+    GC_VALUE op( const GC_VALUE& other ) const \
+    { \
+      VALUE ret = Qnil; \
+      SWIG_RUBY_THREAD_BEGIN_BLOCK; \
+      int status; \
+      OpArgs  args; \
+      args.src    = _obj; \
+      args.id     = proc_id; \
+      args.nargs  = 1; \
+      args.target = VALUE(other); \
+      ret = rb_protect( PROTECTFUNC(swig_protect_funcall), VALUE(&args), \
+			&status ); \
+      SWIG_RUBY_THREAD_END_BLOCK; \
+      return GC_VALUE(ret); \
+    }
+
+    GC_VALUE_BINARY( add_id, operator+ );
+    GC_VALUE_BINARY( sub_id, operator- );
+    GC_VALUE_BINARY( mul_id, operator* );
+    GC_VALUE_BINARY( div_id, operator/ );
+    GC_VALUE_BINARY( mod_id, operator% );
+    
+    GC_VALUE_BINARY( and_id, operator& );
+    GC_VALUE_BINARY( xor_id, operator^ );
+    GC_VALUE_BINARY(  or_id, operator| );
+
+    GC_VALUE_BINARY( lshift_id, operator<< );
+    GC_VALUE_BINARY( rshift_id, operator>> );
+#undef GC_VALUE_BINARY
+
+  };
+
+  ID  GC_VALUE::hash_id = rb_intern("hash");
+  ID  GC_VALUE::lt_id = rb_intern("<");
+  ID  GC_VALUE::gt_id = rb_intern(">");
+  ID  GC_VALUE::eq_id = rb_intern("==");
+  ID  GC_VALUE::le_id = rb_intern("<=");
+  ID  GC_VALUE::ge_id = rb_intern(">=");
+
+  ID  GC_VALUE::pos_id = rb_intern("+@");
+  ID  GC_VALUE::neg_id = rb_intern("-@");
+  ID  GC_VALUE::inv_id = rb_intern("~");
+
+  ID  GC_VALUE::add_id = rb_intern("+");
+  ID  GC_VALUE::sub_id = rb_intern("-");
+  ID  GC_VALUE::mul_id = rb_intern("*");
+  ID  GC_VALUE::div_id = rb_intern("/");
+  ID  GC_VALUE::mod_id = rb_intern("%");
+
+  ID  GC_VALUE::and_id = rb_intern("&");
+  ID  GC_VALUE::or_id  = rb_intern("|");
+  ID  GC_VALUE::xor_id = rb_intern("^");
+
+  ID  GC_VALUE::lshift_id = rb_intern("<<");
+  ID  GC_VALUE::rshift_id = rb_intern(">>");
+
+  VALUE GC_VALUE::_hash = Qnil;
+
+  typedef GC_VALUE LANGUAGE_OBJ;
+
+} // namespace swig
+
+
+
+#if defined(__GNUC__)
+#  if __GNUC__ == 2 && __GNUC_MINOR <= 96
+#     define SWIG_STD_NOMODERN_STL
+#  endif
+#endif
+
+
+#include <string>
 #include <stdexcept>
 
  
-#include "geos_c.h"
-/* Needed for va_start, etc. */
-#include <stdarg.h>
+namespace swig {
+  struct stop_iteration {
+  };
+
+  /** 
+   * Abstract base class used to represent all iterators of STL containers.
+   */
+  struct ConstIterator {
+  public:
+    typedef ConstIterator self_type;
+
+  protected:
+    GC_VALUE _seq;
+
+  protected:
+    ConstIterator(VALUE seq) : _seq(seq)
+    {
+    }
+
+    // Random access iterator methods, but not required in Ruby
+    virtual ptrdiff_t distance(const ConstIterator &x) const
+    {
+      throw std::invalid_argument("distance not supported");
+    }
+
+    virtual bool equal (const ConstIterator &x) const
+    {
+      throw std::invalid_argument("equal not supported");
+    }
+
+    virtual self_type* advance(ptrdiff_t n)
+    {
+      throw std::invalid_argument("advance not supported");
+    }
+      
+  public:
+    virtual ~ConstIterator() {}
+
+    // Access iterator method, required by Ruby
+    virtual VALUE value() const {
+      throw std::invalid_argument("value not supported");
+      return Qnil;
+    };
+
+    virtual VALUE setValue( const VALUE& v ) {
+      throw std::invalid_argument("value= not supported");
+      return Qnil;
+    }
+
+    virtual self_type* next( size_t n = 1 )
+    {
+      return this->advance( n );
+    }
+
+    virtual self_type* previous( size_t n = 1 )
+    {
+      ptrdiff_t nn = n;
+      return this->advance( -nn );
+    }
+
+    virtual VALUE to_s() const {
+      throw std::invalid_argument("to_s not supported");
+      return Qnil;
+    }
+
+    virtual VALUE inspect() const {
+      throw std::invalid_argument("inspect not supported");
+      return Qnil;
+    }
+    
+    virtual ConstIterator *dup() const
+    {
+      throw std::invalid_argument("dup not supported");
+      return NULL;
+    }
+
+    //
+    // C++ common/needed methods.  We emulate a bidirectional
+    // operator, to be compatible with all the STL.
+    // The iterator traits will then tell the STL what type of
+    // iterator we really are.
+    //
+    ConstIterator() : _seq( Qnil )
+    {
+    }
+
+    ConstIterator( const self_type& b ) : _seq( b._seq )
+    {
+    }
+
+    self_type& operator=( const self_type& b )
+    {
+      _seq = b._seq;
+      return *this;
+    }
+
+    bool operator == (const ConstIterator& x)  const
+    {
+      return equal(x);
+    }
+      
+    bool operator != (const ConstIterator& x) const
+    {
+      return ! operator==(x);
+    }
+      
+    // Pre-decrement operator
+    self_type& operator--()
+    {
+      return *previous();
+    }
+
+    // Pre-increment operator
+    self_type& operator++()
+    {
+      return *next();
+    }
+
+    // Post-decrement operator
+    self_type operator--(int)
+    {
+      self_type r = *this;
+      previous();
+      return r;
+    }
+
+    // Post-increment operator
+    self_type operator++(int)
+    {
+      self_type r = *this;
+      next();
+      return r;
+    }
+
+    ConstIterator& operator += (ptrdiff_t n)
+    {
+      return *advance(n);
+    }
+
+    ConstIterator& operator -= (ptrdiff_t n)
+    {
+      return *advance(-n);
+    }
+
+    ConstIterator* operator + (ptrdiff_t n) const
+    {
+      return dup()->advance(n);
+    }
+
+    ConstIterator* operator - (ptrdiff_t n) const
+    {
+      return dup()->advance(-n);
+    }
+      
+    ptrdiff_t operator - (const ConstIterator& x) const
+    {
+      return x.distance(*this);
+    }
+      
+    static swig_type_info* descriptor() {
+      static int init = 0;
+      static swig_type_info* desc = 0;
+      if (!init) {
+	desc = SWIG_TypeQuery("swig::ConstIterator *");
+	init = 1;
+      }	
+      return desc;
+    }
+  };
+
+
+  /**
+   * Abstract base class used to represent all non-const iterators of STL containers.
+   * 
+   */
+  struct Iterator : public ConstIterator {
+  public:
+    typedef Iterator self_type;
+
+  protected:
+    Iterator(VALUE seq) : ConstIterator(seq)
+    {
+    }
+
+    virtual self_type* advance(ptrdiff_t n)
+    {
+      throw std::invalid_argument("operation not supported");
+    }
+
+  public:
+    static swig_type_info* descriptor() {
+      static int init = 0;
+      static swig_type_info* desc = 0;
+      if (!init) {
+	desc = SWIG_TypeQuery("swig::Iterator *");
+	init = 1;
+      }	
+      return desc;
+    }
+    
+    virtual Iterator *dup() const
+    {
+      throw std::invalid_argument("dup not supported");
+      return NULL;
+    }
+      
+    virtual self_type* next( size_t n = 1 )
+    {
+      return this->advance( n );
+    }
+
+    virtual self_type* previous( size_t n = 1 )
+    {
+      ptrdiff_t nn = n;
+      return this->advance( -nn );
+    }
+
+    bool operator == (const ConstIterator& x)  const
+    {
+      return equal(x);
+    }
+      
+    bool operator != (const Iterator& x) const
+    {
+      return ! operator==(x);
+    }
+      
+    Iterator& operator += (ptrdiff_t n)
+    {
+      return *advance(n);
+    }
+
+    Iterator& operator -= (ptrdiff_t n)
+    {
+      return *advance(-n);
+    }
+      
+    Iterator* operator + (ptrdiff_t n) const
+    {
+      return dup()->advance(n);
+    }
+
+    Iterator* operator - (ptrdiff_t n) const
+    {
+      return dup()->advance(-n);
+    }
+      
+    ptrdiff_t operator - (const Iterator& x) const
+    {
+      return x.distance(*this);
+    }
+  };
+
+}
+
+
+SWIGINTERN VALUE
+SWIG_ruby_failed(void)
+{
+  return Qnil;
+} 
+
+
+/*@SWIG:/usr/share/swig1.3/ruby/rubyprimtypes.swg,23,%ruby_aux_method@*/
+SWIGINTERN VALUE SWIG_AUX_NUM2ULONG(VALUE *args)
+{
+  VALUE obj = args[0];
+  VALUE type = TYPE(obj);
+  unsigned long *res = (unsigned long *)(args[1]);
+  *res = type == T_FIXNUM ? NUM2ULONG(obj) : rb_big2ulong(obj);
+  return obj;
+}
+/*@SWIG@*/
+
+SWIGINTERN int
+SWIG_AsVal_unsigned_SS_long (VALUE obj, unsigned long *val) 
+{
+  VALUE type = TYPE(obj);
+  if ((type == T_FIXNUM) || (type == T_BIGNUM)) {
+    unsigned long v;
+    VALUE a[2];
+    a[0] = obj;
+    a[1] = (VALUE)(&v);
+    if (rb_rescue(RUBY_METHOD_FUNC(SWIG_AUX_NUM2ULONG), (VALUE)a, RUBY_METHOD_FUNC(SWIG_ruby_failed), 0) != Qnil) {
+      if (val) *val = v;
+      return SWIG_OK;
+    }
+  }
+  return SWIG_TypeError;
+}
+
+
+SWIGINTERNINLINE int
+SWIG_AsVal_size_t (VALUE obj, size_t *val)
+{
+  unsigned long v;
+  int res = SWIG_AsVal_unsigned_SS_long (obj, val ? &v : 0);
+  if (SWIG_IsOK(res) && val) *val = static_cast< size_t >(v);
+  return res;
+}
+
+
+SWIGINTERNINLINE VALUE
+SWIG_From_bool  (bool value)
+{
+  return value ? Qtrue : Qfalse;
+}
+
+
+/*@SWIG:/usr/share/swig1.3/ruby/rubyprimtypes.swg,23,%ruby_aux_method@*/
+SWIGINTERN VALUE SWIG_AUX_NUM2LONG(VALUE *args)
+{
+  VALUE obj = args[0];
+  VALUE type = TYPE(obj);
+  long *res = (long *)(args[1]);
+  *res = type == T_FIXNUM ? NUM2LONG(obj) : rb_big2long(obj);
+  return obj;
+}
+/*@SWIG@*/
+
+SWIGINTERN int
+SWIG_AsVal_long (VALUE obj, long* val)
+{
+  VALUE type = TYPE(obj);
+  if ((type == T_FIXNUM) || (type == T_BIGNUM)) {
+    long v;
+    VALUE a[2];
+    a[0] = obj;
+    a[1] = (VALUE)(&v);
+    if (rb_rescue(RUBY_METHOD_FUNC(SWIG_AUX_NUM2LONG), (VALUE)a, RUBY_METHOD_FUNC(SWIG_ruby_failed), 0) != Qnil) {
+      if (val) *val = v;
+      return SWIG_OK;
+    }
+  }
+  return SWIG_TypeError;
+}
+
+
+SWIGINTERNINLINE int
+SWIG_AsVal_ptrdiff_t (VALUE obj, ptrdiff_t *val)
+{
+  long v;
+  int res = SWIG_AsVal_long (obj, val ? &v : 0);
+  if (SWIG_IsOK(res) && val) *val = static_cast< ptrdiff_t >(v);
+  return res;
+}
 
 
 #include <limits.h>
-#ifndef LLONG_MIN
-# define LLONG_MIN	LONG_LONG_MIN
-#endif
-#ifndef LLONG_MAX
-# define LLONG_MAX	LONG_LONG_MAX
+#if !defined(SWIG_NO_LLONG_MAX)
+# if !defined(LLONG_MAX) && defined(__GNUC__) && defined (__LONG_LONG_MAX__)
+#   define LLONG_MAX __LONG_LONG_MAX__
+#   define LLONG_MIN (-LLONG_MAX - 1LL)
+#   define ULLONG_MAX (LLONG_MAX * 2ULL + 1ULL)
 #endif
-#ifndef ULLONG_MAX
-# define ULLONG_MAX	ULONG_LONG_MAX
 #endif
 
 
@@ -1646,6 +2514,27 @@
 
 
 SWIGINTERNINLINE VALUE
+SWIG_From_ptrdiff_t  (ptrdiff_t value)
+{    
+  return SWIG_From_long  (static_cast< long >(value));
+}
+
+
+#include <stdexcept>
+
+
+#include <algorithm>
+
+
+#include <vector>
+
+ 
+#include "geos_c.h"
+/* Needed for va_start, etc. */
+#include <stdarg.h>
+
+
+SWIGINTERNINLINE VALUE
 SWIG_From_int  (int value)
 {    
   return SWIG_From_long  (value);
@@ -1714,61 +2603,37 @@
 }
 
 
-typedef void GeosCoordinateSequence;
-
-void checkCoordSeqBounds(const GEOSCoordSeq coordSeq, const size_t index)
-{
-    unsigned int size = 0;
-    GEOSCoordSeq_getSize(coordSeq, &size);
-
-    if (index < 0 || index >= size)
-        throw std::runtime_error("Index out of bounds");
+    /* this callback yields the data item to the block */
+    static void GeosSTRtree_query_callback (void *data, void *nothing) {
+        if (rb_block_given_p()) {
+            rb_yield((VALUE) data);
 }
-
-
-SWIGINTERN VALUE
-SWIG_ruby_failed(void)
-{
-  return Qnil;
 } 
 
 
-/*@SWIG:%ruby_aux_method@*/
-SWIGINTERN VALUE SWIG_AUX_NUM2ULONG(VALUE *args)
+    static void GeosSTRtree_mark_item (void *data, void *nothing)
 {
-  VALUE obj = args[0];
-  VALUE type = TYPE(obj);
-  unsigned long *res = (unsigned long *)(args[1]);
-  *res = type == T_FIXNUM ? NUM2ULONG(obj) : rb_big2ulong(obj);
-  return obj;
+        if ((VALUE) data != Qnil) {
+            rb_gc_mark((VALUE)data);
+        }
 }
-/*@SWIG@*/
 
-SWIGINTERN int
-SWIG_AsVal_unsigned_SS_long (VALUE obj, unsigned long *val) 
+    static void mark_GeosSTRtree(void *self)
 {
-  VALUE type = TYPE(obj);
-  if ((type == T_FIXNUM) || (type == T_BIGNUM)) {
-    unsigned long v;
-    VALUE a[2];
-    a[0] = obj;
-    a[1] = (VALUE)(&v);
-    if (rb_rescue(RUBY_METHOD_FUNC(SWIG_AUX_NUM2ULONG), (VALUE)a, RUBY_METHOD_FUNC(SWIG_ruby_failed), 0) != Qnil) {
-      if (val) *val = v;
-      return SWIG_OK;
-    }
-  }
-  return SWIG_TypeError;
+        GEOSSTRtree *tree = (GEOSSTRtree *) self;
+        GEOSSTRtree_iterate(tree, GeosSTRtree_mark_item, NULL);
 }
 
 
-SWIGINTERNINLINE int
-SWIG_AsVal_size_t (VALUE obj, size_t *val)
+typedef void GeosCoordinateSequence;
+
+void checkCoordSeqBounds(const GEOSCoordSeq coordSeq, const size_t index)
 {
-  unsigned long v;
-  int res = SWIG_AsVal_unsigned_SS_long (obj, val ? &v : 0);
-  if (SWIG_IsOK(res) && val) *val = static_cast< size_t >(v);
-  return res;
+    unsigned int size = 0;
+    GEOSCoordSeq_getSize(coordSeq, &size);
+
+    if (index < 0 || index >= size)
+        throw std::runtime_error("Index out of bounds");
 }
 
 SWIGINTERN GeosCoordinateSequence *new_GeosCoordinateSequence(size_t size,size_t dims){
@@ -1779,13 +2644,13 @@
         return (GeosCoordinateSequence*) GEOSCoordSeq_clone(coords);
     }
 
-/*@SWIG:%ruby_aux_method@*/
+/*@SWIG:/usr/share/swig1.3/ruby/rubyprimtypes.swg,23,%ruby_aux_method@*/
 SWIGINTERN VALUE SWIG_AUX_NUM2DBL(VALUE *args)
 {
   VALUE obj = args[0];
   VALUE type = TYPE(obj);
   double *res = (double *)(args[1]);
-  *res = (type == T_FLOAT ? NUM2DBL(obj) : (type == T_FIXNUM ? (double) FIX2INT(obj) : rb_big2dbl(obj)));
+  *res = NUM2DBL(obj);
   return obj;
 }
 /*@SWIG@*/
@@ -1938,35 +2803,6 @@
         return GEOSGetSRID(geom);
     }
 
-/*@SWIG:%ruby_aux_method@*/
-SWIGINTERN VALUE SWIG_AUX_NUM2LONG(VALUE *args)
-{
-  VALUE obj = args[0];
-  VALUE type = TYPE(obj);
-  long *res = (long *)(args[1]);
-  *res = type == T_FIXNUM ? NUM2LONG(obj) : rb_big2long(obj);
-  return obj;
-}
-/*@SWIG@*/
-
-SWIGINTERN int
-SWIG_AsVal_long (VALUE obj, long* val)
-{
-  VALUE type = TYPE(obj);
-  if ((type == T_FIXNUM) || (type == T_BIGNUM)) {
-    long v;
-    VALUE a[2];
-    a[0] = obj;
-    a[1] = (VALUE)(&v);
-    if (rb_rescue(RUBY_METHOD_FUNC(SWIG_AUX_NUM2LONG), (VALUE)a, RUBY_METHOD_FUNC(SWIG_ruby_failed), 0) != Qnil) {
-      if (val) *val = v;
-      return SWIG_OK;
-    }
-  }
-  return SWIG_TypeError;
-}
-
-
 SWIGINTERN int
 SWIG_AsVal_int (VALUE obj, int *val)
 {
@@ -2072,11 +2908,11 @@
 SWIG_AsCharPtrAndSize(VALUE obj, char** cptr, size_t* psize, int *alloc)
 {
   if (TYPE(obj) == T_STRING) {
-    
-
-
+    #if defined(StringValuePtr)
+    char *cstr = StringValuePtr(obj); 
+    #else
     char *cstr = STR2CSTR(obj);
-    
+    #endif
     size_t size = RSTRING_LEN(obj) + 1;
     if (cptr)  {
       if (alloc) {
@@ -2113,13 +2949,6 @@
         GEOSGeom otherGeom = (GEOSGeom) other;
         return checkBoolResult(GEOSRelatePattern(geom, otherGeom, pat));
     }
-
-SWIGINTERNINLINE VALUE
-SWIG_From_bool  (bool value)
-{
-  return value ? Qtrue : Qfalse;
-}
-
 SWIGINTERN bool GeosGeometry_disjoint(GeosGeometry *self,GeosGeometry const *other){
         GEOSGeom geom = (GEOSGeom) self;
         GEOSGeom otherGeom = (GEOSGeom) other;
@@ -2335,6 +3164,67 @@
 }
 
 
+
+typedef void GeosPreparedGeometry;
+
+SWIGINTERN GeosPreparedGeometry *new_GeosPreparedGeometry(GeosGeometry const *source){
+        const GEOSPreparedGeometry *prep = GEOSPrepare((const GEOSGeometry *)source);
+        if(prep == NULL)
+            throw std::runtime_error(message);
+        return (GeosPreparedGeometry *) prep;
+    }
+SWIGINTERN bool GeosPreparedGeometry_contains(GeosPreparedGeometry *self,GeosGeometry const *other){
+        GEOSPreparedGeometry *prep = (GEOSPreparedGeometry *) self;
+        GEOSGeom otherGeom = (GEOSGeom) other;
+        return checkBoolResult(GEOSPreparedContains(prep, otherGeom));
+    }
+SWIGINTERN bool GeosPreparedGeometry_containsProperly(GeosPreparedGeometry *self,GeosGeometry const *other){
+        GEOSPreparedGeometry *prep = (GEOSPreparedGeometry *) self;
+        GEOSGeom otherGeom = (GEOSGeom) other;
+        return checkBoolResult(GEOSPreparedContainsProperly(prep, otherGeom));
+    }
+SWIGINTERN bool GeosPreparedGeometry_covers(GeosPreparedGeometry *self,GeosGeometry const *other){
+        GEOSPreparedGeometry *prep = (GEOSPreparedGeometry *) self;
+        GEOSGeom otherGeom = (GEOSGeom) other;
+        return checkBoolResult(GEOSPreparedCovers(prep, otherGeom));
+    }
+SWIGINTERN bool GeosPreparedGeometry_intersects(GeosPreparedGeometry *self,GeosGeometry const *other){
+        GEOSPreparedGeometry *prep = (GEOSPreparedGeometry *) self;
+        GEOSGeom otherGeom = (GEOSGeom) other;
+        return checkBoolResult(GEOSPreparedIntersects(prep, otherGeom));
+    }
+
+typedef void GeosSTRtree;
+/* GeosIndexItem typedef'd here so it can be %typemap(typecheck)'d
+   as a native object by each language specially */
+typedef void *GeosIndexItem;
+typedef GEOSQueryCallback GeosQueryCallback;
+
+SWIGINTERN GeosSTRtree *new_GeosSTRtree(int nodeCapacity){
+        GEOSSTRtree *tree = GEOSSTRtree_create(nodeCapacity);
+        if(tree == NULL)
+            throw std::runtime_error(message);
+        return (GeosSTRtree *) tree;
+    }
+SWIGINTERN void GeosSTRtree_insert(GeosSTRtree *self,GeosGeometry const *g,GeosIndexItem item){
+        GEOSSTRtree *tree = (GEOSSTRtree *) self;
+        const GEOSGeometry *geom = (const GEOSGeometry *) g;
+        GEOSSTRtree_insert(tree, geom, item);
+    }
+SWIGINTERN void GeosSTRtree_remove(GeosSTRtree *self,GeosGeometry const *g,GeosIndexItem item){
+        GEOSSTRtree *tree = (GEOSSTRtree *) self;
+        const GEOSGeometry *geom = (const GEOSGeometry *) g;
+        GEOSSTRtree_remove(tree, geom, item);
+    }
+SWIGINTERN void GeosSTRtree_query(GeosSTRtree *self,GeosGeometry const *g,GeosQueryCallback callback,GeosIndexItem accumulator){
+        GEOSSTRtree *tree = (GEOSSTRtree *) self;
+        const GEOSGeometry *geom = (const GEOSGeometry *) g;
+        GEOSSTRtree_query(tree, geom, callback, accumulator);
+    }
+SWIGINTERN void GeosSTRtree_iterate(GeosSTRtree *self,GeosQueryCallback callback,GeosIndexItem accumulator){
+        GEOSSTRtree *tree = (GEOSSTRtree *) self;
+        GEOSSTRtree_iterate(tree, callback, accumulator);
+    }
 SWIGINTERN GeosWktReader *new_GeosWktReader(){
         return GEOSWKTReader_create();
     }
@@ -2442,6 +3332,1256 @@
         GEOSGeom geom = (GEOSGeom) g;
         return GEOSWKBWriter_writeHEX(writer, geom, size);
     }
+swig_class SwigClassGCVALUE;
+
+
+/*
+  Document-method: Geos::GCVALUE.inspect
+
+  call-seq:
+    inspect -> VALUE
+
+Inspect class and its contents.
+*/
+SWIGINTERN VALUE
+_wrap_GCVALUE_inspect(int argc, VALUE *argv, VALUE self) {
+  swig::GC_VALUE *arg1 = (swig::GC_VALUE *) 0 ;
+  void *argp1 = 0 ;
+  int res1 = 0 ;
+  VALUE result;
+  VALUE vresult = Qnil;
+  
+  if ((argc < 0) || (argc > 0)) {
+    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;
+  }
+  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_swig__GC_VALUE, 0 |  0 );
+  if (!SWIG_IsOK(res1)) {
+    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "swig::GC_VALUE const *","inspect", 1, self )); 
+  }
+  arg1 = reinterpret_cast< swig::GC_VALUE * >(argp1);
+  result = (VALUE)((swig::GC_VALUE const *)arg1)->inspect();
+  vresult = result;
+  return vresult;
+fail:
+  return Qnil;
+}
+
+
+
+/*
+  Document-method: Geos::GCVALUE.to_s
+
+  call-seq:
+    to_s -> VALUE
+
+Convert class to a String representation.
+*/
+SWIGINTERN VALUE
+_wrap_GCVALUE_to_s(int argc, VALUE *argv, VALUE self) {
+  swig::GC_VALUE *arg1 = (swig::GC_VALUE *) 0 ;
+  void *argp1 = 0 ;
+  int res1 = 0 ;
+  VALUE result;
+  VALUE vresult = Qnil;
+  
+  if ((argc < 0) || (argc > 0)) {
+    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;
+  }
+  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_swig__GC_VALUE, 0 |  0 );
+  if (!SWIG_IsOK(res1)) {
+    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "swig::GC_VALUE const *","to_s", 1, self )); 
+  }
+  arg1 = reinterpret_cast< swig::GC_VALUE * >(argp1);
+  result = (VALUE)((swig::GC_VALUE const *)arg1)->to_s();
+  vresult = result;
+  return vresult;
+fail:
+  return Qnil;
+}
+
+
+swig_class SwigClassConstIterator;
+
+SWIGINTERN void
+free_swig_ConstIterator(swig::ConstIterator *arg1) {
+    delete arg1;
+}
+
+SWIGINTERN VALUE
+_wrap_ConstIterator_value(int argc, VALUE *argv, VALUE self) {
+  swig::ConstIterator *arg1 = (swig::ConstIterator *) 0 ;
+  void *argp1 = 0 ;
+  int res1 = 0 ;
+  VALUE result;
+  VALUE vresult = Qnil;
+  
+  if ((argc < 0) || (argc > 0)) {
+    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;
+  }
+  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_swig__ConstIterator, 0 |  0 );
+  if (!SWIG_IsOK(res1)) {
+    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "swig::ConstIterator const *","value", 1, self )); 
+  }
+  arg1 = reinterpret_cast< swig::ConstIterator * >(argp1);
+  try {
+    result = (VALUE)((swig::ConstIterator const *)arg1)->value();
+  }
+  catch(swig::stop_iteration &_e) {
+    {
+      (void)_e;
+      SWIG_Ruby_ExceptionType(NULL, Qnil);
+      SWIG_fail;
+    }
+  }
+  
+  vresult = result;
+  return vresult;
+fail:
+  return Qnil;
+}
+
+
+
+/*
+  Document-method: Geos::ConstIterator.dup
+
+  call-seq:
+    dup -> ConstIterator
+
+Create a duplicate of the class and unfreeze it if needed.
+*/
+SWIGINTERN VALUE
+_wrap_ConstIterator_dup(int argc, VALUE *argv, VALUE self) {
+  swig::ConstIterator *arg1 = (swig::ConstIterator *) 0 ;
+  void *argp1 = 0 ;
+  int res1 = 0 ;
+  swig::ConstIterator *result = 0 ;
+  VALUE vresult = Qnil;
+  
+  if ((argc < 0) || (argc > 0)) {
+    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;
+  }
+  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_swig__ConstIterator, 0 |  0 );
+  if (!SWIG_IsOK(res1)) {
+    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "swig::ConstIterator const *","dup", 1, self )); 
+  }
+  arg1 = reinterpret_cast< swig::ConstIterator * >(argp1);
+  result = (swig::ConstIterator *)((swig::ConstIterator const *)arg1)->dup();
+  vresult = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_swig__ConstIterator, SWIG_POINTER_OWN |  0 );
+  return vresult;
+fail:
+  return Qnil;
+}
+
+
+
+/*
+  Document-method: Geos::ConstIterator.inspect
+
+  call-seq:
+    inspect -> VALUE
+
+Inspect class and its contents.
+*/
+SWIGINTERN VALUE
+_wrap_ConstIterator_inspect(int argc, VALUE *argv, VALUE self) {
+  swig::ConstIterator *arg1 = (swig::ConstIterator *) 0 ;
+  void *argp1 = 0 ;
+  int res1 = 0 ;
+  VALUE result;
+  VALUE vresult = Qnil;
+  
+  if ((argc < 0) || (argc > 0)) {
+    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;
+  }
+  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_swig__ConstIterator, 0 |  0 );
+  if (!SWIG_IsOK(res1)) {
+    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "swig::ConstIterator const *","inspect", 1, self )); 
+  }
+  arg1 = reinterpret_cast< swig::ConstIterator * >(argp1);
+  result = (VALUE)((swig::ConstIterator const *)arg1)->inspect();
+  vresult = result;
+  return vresult;
+fail:
+  return Qnil;
+}
+
+
+
+/*
+  Document-method: Geos::ConstIterator.to_s
+
+  call-seq:
+    to_s -> VALUE
+
+Convert class to a String representation.
+*/
+SWIGINTERN VALUE
+_wrap_ConstIterator_to_s(int argc, VALUE *argv, VALUE self) {
+  swig::ConstIterator *arg1 = (swig::ConstIterator *) 0 ;
+  void *argp1 = 0 ;
+  int res1 = 0 ;
+  VALUE result;
+  VALUE vresult = Qnil;
+  
+  if ((argc < 0) || (argc > 0)) {
+    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;
+  }
+  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_swig__ConstIterator, 0 |  0 );
+  if (!SWIG_IsOK(res1)) {
+    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "swig::ConstIterator const *","to_s", 1, self )); 
+  }
+  arg1 = reinterpret_cast< swig::ConstIterator * >(argp1);
+  result = (VALUE)((swig::ConstIterator const *)arg1)->to_s();
+  vresult = result;
+  return vresult;
+fail:
+  return Qnil;
+}
+
+
+SWIGINTERN VALUE
+_wrap_ConstIterator_next__SWIG_0(int argc, VALUE *argv, VALUE self) {
+  swig::ConstIterator *arg1 = (swig::ConstIterator *) 0 ;
+  size_t arg2 ;
+  void *argp1 = 0 ;
+  int res1 = 0 ;
+  size_t val2 ;
+  int ecode2 = 0 ;
+  swig::ConstIterator *result = 0 ;
+  VALUE vresult = Qnil;
+  
+  if ((argc < 1) || (argc > 1)) {
+    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc); SWIG_fail;
+  }
+  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_swig__ConstIterator, 0 |  0 );
+  if (!SWIG_IsOK(res1)) {
+    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "swig::ConstIterator *","next", 1, self )); 
+  }
+  arg1 = reinterpret_cast< swig::ConstIterator * >(argp1);
+  ecode2 = SWIG_AsVal_size_t(argv[0], &val2);
+  if (!SWIG_IsOK(ecode2)) {
+    SWIG_exception_fail(SWIG_ArgError(ecode2), Ruby_Format_TypeError( "", "size_t","next", 2, argv[0] ));
+  } 
+  arg2 = static_cast< size_t >(val2);
+  result = (swig::ConstIterator *)(arg1)->next(arg2);
+  vresult = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_swig__ConstIterator, 0 |  0 );
+  return vresult;
+fail:
+  return Qnil;
+}
+
+
+SWIGINTERN VALUE
+_wrap_ConstIterator_next__SWIG_1(int argc, VALUE *argv, VALUE self) {
+  swig::ConstIterator *arg1 = (swig::ConstIterator *) 0 ;
+  void *argp1 = 0 ;
+  int res1 = 0 ;
+  swig::ConstIterator *result = 0 ;
+  VALUE vresult = Qnil;
+  
+  if ((argc < 0) || (argc > 0)) {
+    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;
+  }
+  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_swig__ConstIterator, 0 |  0 );
+  if (!SWIG_IsOK(res1)) {
+    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "swig::ConstIterator *","next", 1, self )); 
+  }
+  arg1 = reinterpret_cast< swig::ConstIterator * >(argp1);
+  try {
+    result = (swig::ConstIterator *)(arg1)->next();
+  }
+  catch(swig::stop_iteration &_e) {
+    {
+      (void)_e;
+      SWIG_Ruby_ExceptionType(NULL, Qnil);
+      SWIG_fail;
+    }
+  }
+  
+  vresult = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_swig__ConstIterator, 0 |  0 );
+  return vresult;
+fail:
+  return Qnil;
+}
+
+
+SWIGINTERN VALUE _wrap_ConstIterator_next(int nargs, VALUE *args, VALUE self) {
+  int argc;
+  VALUE argv[3];
+  int ii;
+  
+  argc = nargs + 1;
+  argv[0] = self;
+  if (argc > 3) SWIG_fail;
+  for (ii = 1; (ii < argc); ++ii) {
+    argv[ii] = args[ii-1];
+  }
+  if (argc == 1) {
+    int _v;
+    void *vptr = 0;
+    int res = SWIG_ConvertPtr(argv[0], &vptr, SWIGTYPE_p_swig__ConstIterator, 0);
+    _v = SWIG_CheckState(res);
+    if (_v) {
+      return _wrap_ConstIterator_next__SWIG_1(nargs, args, self);
+    }
+  }
+  if (argc == 2) {
+    int _v;
+    void *vptr = 0;
+    int res = SWIG_ConvertPtr(argv[0], &vptr, SWIGTYPE_p_swig__ConstIterator, 0);
+    _v = SWIG_CheckState(res);
+    if (_v) {
+      {
+        int res = SWIG_AsVal_size_t(argv[1], NULL);
+        _v = SWIG_CheckState(res);
+      }
+      if (_v) {
+        return _wrap_ConstIterator_next__SWIG_0(nargs, args, self);
+      }
+    }
+  }
+  
+fail:
+  Ruby_Format_OverloadedError( argc, 3, "ConstIterator.next", 
+    "    swig::ConstIterator * ConstIterator.next(size_t n)\n"
+    "    swig::ConstIterator * ConstIterator.next()\n");
+  
+  return Qnil;
+}
+
+
+SWIGINTERN VALUE
+_wrap_ConstIterator_previous__SWIG_0(int argc, VALUE *argv, VALUE self) {
+  swig::ConstIterator *arg1 = (swig::ConstIterator *) 0 ;
+  size_t arg2 ;
+  void *argp1 = 0 ;
+  int res1 = 0 ;
+  size_t val2 ;
+  int ecode2 = 0 ;
+  swig::ConstIterator *result = 0 ;
+  VALUE vresult = Qnil;
+  
+  if ((argc < 1) || (argc > 1)) {
+    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc); SWIG_fail;
+  }
+  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_swig__ConstIterator, 0 |  0 );
+  if (!SWIG_IsOK(res1)) {
+    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "swig::ConstIterator *","previous", 1, self )); 
+  }
+  arg1 = reinterpret_cast< swig::ConstIterator * >(argp1);
+  ecode2 = SWIG_AsVal_size_t(argv[0], &val2);
+  if (!SWIG_IsOK(ecode2)) {
+    SWIG_exception_fail(SWIG_ArgError(ecode2), Ruby_Format_TypeError( "", "size_t","previous", 2, argv[0] ));
+  } 
+  arg2 = static_cast< size_t >(val2);
+  result = (swig::ConstIterator *)(arg1)->previous(arg2);
+  vresult = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_swig__ConstIterator, 0 |  0 );
+  return vresult;
+fail:
+  return Qnil;
+}
+
+
+SWIGINTERN VALUE
+_wrap_ConstIterator_previous__SWIG_1(int argc, VALUE *argv, VALUE self) {
+  swig::ConstIterator *arg1 = (swig::ConstIterator *) 0 ;
+  void *argp1 = 0 ;
+  int res1 = 0 ;
+  swig::ConstIterator *result = 0 ;
+  VALUE vresult = Qnil;
+  
+  if ((argc < 0) || (argc > 0)) {
+    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;
+  }
+  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_swig__ConstIterator, 0 |  0 );
+  if (!SWIG_IsOK(res1)) {
+    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "swig::ConstIterator *","previous", 1, self )); 
+  }
+  arg1 = reinterpret_cast< swig::ConstIterator * >(argp1);
+  try {
+    result = (swig::ConstIterator *)(arg1)->previous();
+  }
+  catch(swig::stop_iteration &_e) {
+    {
+      (void)_e;
+      SWIG_Ruby_ExceptionType(NULL, Qnil);
+      SWIG_fail;
+    }
+  }
+  
+  vresult = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_swig__ConstIterator, 0 |  0 );
+  return vresult;
+fail:
+  return Qnil;
+}
+
+
+SWIGINTERN VALUE _wrap_ConstIterator_previous(int nargs, VALUE *args, VALUE self) {
+  int argc;
+  VALUE argv[3];
+  int ii;
+  
+  argc = nargs + 1;
+  argv[0] = self;
+  if (argc > 3) SWIG_fail;
+  for (ii = 1; (ii < argc); ++ii) {
+    argv[ii] = args[ii-1];
+  }
+  if (argc == 1) {
+    int _v;
+    void *vptr = 0;
+    int res = SWIG_ConvertPtr(argv[0], &vptr, SWIGTYPE_p_swig__ConstIterator, 0);
+    _v = SWIG_CheckState(res);
+    if (_v) {
+      return _wrap_ConstIterator_previous__SWIG_1(nargs, args, self);
+    }
+  }
+  if (argc == 2) {
+    int _v;
+    void *vptr = 0;
+    int res = SWIG_ConvertPtr(argv[0], &vptr, SWIGTYPE_p_swig__ConstIterator, 0);
+    _v = SWIG_CheckState(res);
+    if (_v) {
+      {
+        int res = SWIG_AsVal_size_t(argv[1], NULL);
+        _v = SWIG_CheckState(res);
+      }
+      if (_v) {
+        return _wrap_ConstIterator_previous__SWIG_0(nargs, args, self);
+      }
+    }
+  }
+  
+fail:
+  Ruby_Format_OverloadedError( argc, 3, "ConstIterator.previous", 
+    "    swig::ConstIterator * ConstIterator.previous(size_t n)\n"
+    "    swig::ConstIterator * ConstIterator.previous()\n");
+  
+  return Qnil;
+}
+
+
+
+/*
+  Document-method: Geos::ConstIterator.==
+
+  call-seq:
+    ==(x) -> bool
+
+Equality comparison operator.
+*/
+SWIGINTERN VALUE
+_wrap_ConstIterator___eq__(int argc, VALUE *argv, VALUE self) {
+  swig::ConstIterator *arg1 = (swig::ConstIterator *) 0 ;
+  swig::ConstIterator *arg2 = 0 ;
+  void *argp1 = 0 ;
+  int res1 = 0 ;
+  void *argp2 ;
+  int res2 = 0 ;
+  bool result;
+  VALUE vresult = Qnil;
+  
+  if ((argc < 1) || (argc > 1)) {
+    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc); SWIG_fail;
+  }
+  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_swig__ConstIterator, 0 |  0 );
+  if (!SWIG_IsOK(res1)) {
+    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "swig::ConstIterator const *","operator ==", 1, self )); 
+  }
+  arg1 = reinterpret_cast< swig::ConstIterator * >(argp1);
+  res2 = SWIG_ConvertPtr(argv[0], &argp2, SWIGTYPE_p_swig__ConstIterator,  0 );
+  if (!SWIG_IsOK(res2)) {
+    SWIG_exception_fail(SWIG_ArgError(res2), Ruby_Format_TypeError( "", "swig::ConstIterator const &","operator ==", 2, argv[0] )); 
+  }
+  if (!argp2) {
+    SWIG_exception_fail(SWIG_ValueError, Ruby_Format_TypeError("invalid null reference ", "swig::ConstIterator const &","operator ==", 2, argv[0])); 
+  }
+  arg2 = reinterpret_cast< swig::ConstIterator * >(argp2);
+  result = (bool)((swig::ConstIterator const *)arg1)->operator ==((swig::ConstIterator const &)*arg2);
+  vresult = SWIG_From_bool(static_cast< bool >(result));
+  return vresult;
+fail:
+  return Qnil;
+}
+
+
+
+/*
+  Document-method: Geos::ConstIterator.+
+
+  call-seq:
+    +(n) -> ConstIterator
+
+Add operator.
+*/
+SWIGINTERN VALUE
+_wrap_ConstIterator___add__(int argc, VALUE *argv, VALUE self) {
+  swig::ConstIterator *arg1 = (swig::ConstIterator *) 0 ;
+  ptrdiff_t arg2 ;
+  void *argp1 = 0 ;
+  int res1 = 0 ;
+  ptrdiff_t val2 ;
+  int ecode2 = 0 ;
+  swig::ConstIterator *result = 0 ;
+  VALUE vresult = Qnil;
+  
+  if ((argc < 1) || (argc > 1)) {
+    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc); SWIG_fail;
+  }
+  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_swig__ConstIterator, 0 |  0 );
+  if (!SWIG_IsOK(res1)) {
+    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "swig::ConstIterator const *","operator +", 1, self )); 
+  }
+  arg1 = reinterpret_cast< swig::ConstIterator * >(argp1);
+  ecode2 = SWIG_AsVal_ptrdiff_t(argv[0], &val2);
+  if (!SWIG_IsOK(ecode2)) {
+    SWIG_exception_fail(SWIG_ArgError(ecode2), Ruby_Format_TypeError( "", "ptrdiff_t","operator +", 2, argv[0] ));
+  } 
+  arg2 = static_cast< ptrdiff_t >(val2);
+  try {
+    result = (swig::ConstIterator *)((swig::ConstIterator const *)arg1)->operator +(arg2);
+  }
+  catch(swig::stop_iteration &_e) {
+    {
+      (void)_e;
+      SWIG_Ruby_ExceptionType(NULL, Qnil);
+      SWIG_fail;
+    }
+  }
+  
+  vresult = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_swig__ConstIterator, SWIG_POINTER_OWN |  0 );
+  return vresult;
+fail:
+  return Qnil;
+}
+
+
+
+/*
+  Document-method: Geos::ConstIterator.-
+
+  call-seq:
+    -(n) -> ConstIterator
+    -(x) -> ptrdiff_t
+
+Substraction operator.
+*/
+SWIGINTERN VALUE
+_wrap_ConstIterator___sub____SWIG_0(int argc, VALUE *argv, VALUE self) {
+  swig::ConstIterator *arg1 = (swig::ConstIterator *) 0 ;
+  ptrdiff_t arg2 ;
+  void *argp1 = 0 ;
+  int res1 = 0 ;
+  ptrdiff_t val2 ;
+  int ecode2 = 0 ;
+  swig::ConstIterator *result = 0 ;
+  VALUE vresult = Qnil;
+  
+  if ((argc < 1) || (argc > 1)) {
+    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc); SWIG_fail;
+  }
+  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_swig__ConstIterator, 0 |  0 );
+  if (!SWIG_IsOK(res1)) {
+    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "swig::ConstIterator const *","operator -", 1, self )); 
+  }
+  arg1 = reinterpret_cast< swig::ConstIterator * >(argp1);
+  ecode2 = SWIG_AsVal_ptrdiff_t(argv[0], &val2);
+  if (!SWIG_IsOK(ecode2)) {
+    SWIG_exception_fail(SWIG_ArgError(ecode2), Ruby_Format_TypeError( "", "ptrdiff_t","operator -", 2, argv[0] ));
+  } 
+  arg2 = static_cast< ptrdiff_t >(val2);
+  try {
+    result = (swig::ConstIterator *)((swig::ConstIterator const *)arg1)->operator -(arg2);
+  }
+  catch(swig::stop_iteration &_e) {
+    {
+      (void)_e;
+      SWIG_Ruby_ExceptionType(NULL, Qnil);
+      SWIG_fail;
+    }
+  }
+  
+  vresult = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_swig__ConstIterator, SWIG_POINTER_OWN |  0 );
+  return vresult;
+fail:
+  return Qnil;
+}
+
+
+SWIGINTERN VALUE
+_wrap_ConstIterator___sub____SWIG_1(int argc, VALUE *argv, VALUE self) {
+  swig::ConstIterator *arg1 = (swig::ConstIterator *) 0 ;
+  swig::ConstIterator *arg2 = 0 ;
+  void *argp1 = 0 ;
+  int res1 = 0 ;
+  void *argp2 ;
+  int res2 = 0 ;
+  ptrdiff_t result;
+  VALUE vresult = Qnil;
+  
+  if ((argc < 1) || (argc > 1)) {
+    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc); SWIG_fail;
+  }
+  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_swig__ConstIterator, 0 |  0 );
+  if (!SWIG_IsOK(res1)) {
+    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "swig::ConstIterator const *","operator -", 1, self )); 
+  }
+  arg1 = reinterpret_cast< swig::ConstIterator * >(argp1);
+  res2 = SWIG_ConvertPtr(argv[0], &argp2, SWIGTYPE_p_swig__ConstIterator,  0 );
+  if (!SWIG_IsOK(res2)) {
+    SWIG_exception_fail(SWIG_ArgError(res2), Ruby_Format_TypeError( "", "swig::ConstIterator const &","operator -", 2, argv[0] )); 
+  }
+  if (!argp2) {
+    SWIG_exception_fail(SWIG_ValueError, Ruby_Format_TypeError("invalid null reference ", "swig::ConstIterator const &","operator -", 2, argv[0])); 
+  }
+  arg2 = reinterpret_cast< swig::ConstIterator * >(argp2);
+  result = ((swig::ConstIterator const *)arg1)->operator -((swig::ConstIterator const &)*arg2);
+  vresult = SWIG_From_ptrdiff_t(static_cast< ptrdiff_t >(result));
+  return vresult;
+fail:
+  return Qnil;
+}
+
+
+SWIGINTERN VALUE _wrap_ConstIterator___sub__(int nargs, VALUE *args, VALUE self) {
+  int argc;
+  VALUE argv[3];
+  int ii;
+  
+  argc = nargs + 1;
+  argv[0] = self;
+  if (argc > 3) SWIG_fail;
+  for (ii = 1; (ii < argc); ++ii) {
+    argv[ii] = args[ii-1];
+  }
+  if (argc == 2) {
+    int _v;
+    void *vptr = 0;
+    int res = SWIG_ConvertPtr(argv[0], &vptr, SWIGTYPE_p_swig__ConstIterator, 0);
+    _v = SWIG_CheckState(res);
+    if (_v) {
+      void *vptr = 0;
+      int res = SWIG_ConvertPtr(argv[1], &vptr, SWIGTYPE_p_swig__ConstIterator, 0);
+      _v = SWIG_CheckState(res);
+      if (_v) {
+        return _wrap_ConstIterator___sub____SWIG_1(nargs, args, self);
+      }
+    }
+  }
+  if (argc == 2) {
+    int _v;
+    void *vptr = 0;
+    int res = SWIG_ConvertPtr(argv[0], &vptr, SWIGTYPE_p_swig__ConstIterator, 0);
+    _v = SWIG_CheckState(res);
+    if (_v) {
+      {
+        int res = SWIG_AsVal_ptrdiff_t(argv[1], NULL);
+        _v = SWIG_CheckState(res);
+      }
+      if (_v) {
+        return _wrap_ConstIterator___sub____SWIG_0(nargs, args, self);
+      }
+    }
+  }
+  
+fail:
+  Ruby_Format_OverloadedError( argc, 3, "__sub__.new", 
+    "    __sub__.new(ptrdiff_t n)\n"
+    "    __sub__.new(swig::ConstIterator const &x)\n");
+  
+  return Qnil;
+}
+
+
+swig_class SwigClassIterator;
+
+SWIGINTERN VALUE
+_wrap_Iterator_valuee___(int argc, VALUE *argv, VALUE self) {
+  swig::Iterator *arg1 = (swig::Iterator *) 0 ;
+  VALUE *arg2 = 0 ;
+  void *argp1 = 0 ;
+  int res1 = 0 ;
+  VALUE temp2 ;
+  VALUE result;
+  VALUE vresult = Qnil;
+  
+  if ((argc < 1) || (argc > 1)) {
+    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc); SWIG_fail;
+  }
+  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_swig__Iterator, 0 |  0 );
+  if (!SWIG_IsOK(res1)) {
+    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "swig::Iterator *","setValue", 1, self )); 
+  }
+  arg1 = reinterpret_cast< swig::Iterator * >(argp1);
+  temp2 = static_cast< VALUE >(argv[0]);
+  arg2 = &temp2;
+  result = (VALUE)(arg1)->setValue((VALUE const &)*arg2);
+  vresult = result;
+  return vresult;
+fail:
+  return Qnil;
+}
+
+
+
+/*
+  Document-method: Geos::Iterator.dup
+
+  call-seq:
+    dup -> Iterator
+
+Create a duplicate of the class and unfreeze it if needed.
+*/
+SWIGINTERN VALUE
+_wrap_Iterator_dup(int argc, VALUE *argv, VALUE self) {
+  swig::Iterator *arg1 = (swig::Iterator *) 0 ;
+  void *argp1 = 0 ;
+  int res1 = 0 ;
+  swig::Iterator *result = 0 ;
+  VALUE vresult = Qnil;
+  
+  if ((argc < 0) || (argc > 0)) {
+    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;
+  }
+  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_swig__Iterator, 0 |  0 );
+  if (!SWIG_IsOK(res1)) {
+    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "swig::Iterator const *","dup", 1, self )); 
+  }
+  arg1 = reinterpret_cast< swig::Iterator * >(argp1);
+  result = (swig::Iterator *)((swig::Iterator const *)arg1)->dup();
+  vresult = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_swig__Iterator, SWIG_POINTER_OWN |  0 );
+  return vresult;
+fail:
+  return Qnil;
+}
+
+
+SWIGINTERN VALUE
+_wrap_Iterator_next__SWIG_0(int argc, VALUE *argv, VALUE self) {
+  swig::Iterator *arg1 = (swig::Iterator *) 0 ;
+  size_t arg2 ;
+  void *argp1 = 0 ;
+  int res1 = 0 ;
+  size_t val2 ;
+  int ecode2 = 0 ;
+  swig::Iterator *result = 0 ;
+  VALUE vresult = Qnil;
+  
+  if ((argc < 1) || (argc > 1)) {
+    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc); SWIG_fail;
+  }
+  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_swig__Iterator, 0 |  0 );
+  if (!SWIG_IsOK(res1)) {
+    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "swig::Iterator *","next", 1, self )); 
+  }
+  arg1 = reinterpret_cast< swig::Iterator * >(argp1);
+  ecode2 = SWIG_AsVal_size_t(argv[0], &val2);
+  if (!SWIG_IsOK(ecode2)) {
+    SWIG_exception_fail(SWIG_ArgError(ecode2), Ruby_Format_TypeError( "", "size_t","next", 2, argv[0] ));
+  } 
+  arg2 = static_cast< size_t >(val2);
+  result = (swig::Iterator *)(arg1)->next(arg2);
+  vresult = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_swig__Iterator, 0 |  0 );
+  return vresult;
+fail:
+  return Qnil;
+}
+
+
+SWIGINTERN VALUE
+_wrap_Iterator_next__SWIG_1(int argc, VALUE *argv, VALUE self) {
+  swig::Iterator *arg1 = (swig::Iterator *) 0 ;
+  void *argp1 = 0 ;
+  int res1 = 0 ;
+  swig::Iterator *result = 0 ;
+  VALUE vresult = Qnil;
+  
+  if ((argc < 0) || (argc > 0)) {
+    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;
+  }
+  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_swig__Iterator, 0 |  0 );
+  if (!SWIG_IsOK(res1)) {
+    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "swig::Iterator *","next", 1, self )); 
+  }
+  arg1 = reinterpret_cast< swig::Iterator * >(argp1);
+  try {
+    result = (swig::Iterator *)(arg1)->next();
+  }
+  catch(swig::stop_iteration &_e) {
+    {
+      (void)_e;
+      SWIG_Ruby_ExceptionType(NULL, Qnil);
+      SWIG_fail;
+    }
+  }
+  
+  vresult = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_swig__Iterator, 0 |  0 );
+  return vresult;
+fail:
+  return Qnil;
+}
+
+
+SWIGINTERN VALUE _wrap_Iterator_next(int nargs, VALUE *args, VALUE self) {
+  int argc;
+  VALUE argv[3];
+  int ii;
+  
+  argc = nargs + 1;
+  argv[0] = self;
+  if (argc > 3) SWIG_fail;
+  for (ii = 1; (ii < argc); ++ii) {
+    argv[ii] = args[ii-1];
+  }
+  if (argc == 1) {
+    int _v;
+    void *vptr = 0;
+    int res = SWIG_ConvertPtr(argv[0], &vptr, SWIGTYPE_p_swig__Iterator, 0);
+    _v = SWIG_CheckState(res);
+    if (_v) {
+      return _wrap_Iterator_next__SWIG_1(nargs, args, self);
+    }
+  }
+  if (argc == 2) {
+    int _v;
+    void *vptr = 0;
+    int res = SWIG_ConvertPtr(argv[0], &vptr, SWIGTYPE_p_swig__Iterator, 0);
+    _v = SWIG_CheckState(res);
+    if (_v) {
+      {
+        int res = SWIG_AsVal_size_t(argv[1], NULL);
+        _v = SWIG_CheckState(res);
+      }
+      if (_v) {
+        return _wrap_Iterator_next__SWIG_0(nargs, args, self);
+      }
+    }
+  }
+  
+fail:
+  Ruby_Format_OverloadedError( argc, 3, "Iterator.next", 
+    "    swig::Iterator * Iterator.next(size_t n)\n"
+    "    swig::Iterator * Iterator.next()\n");
+  
+  return Qnil;
+}
+
+
+SWIGINTERN VALUE
+_wrap_Iterator_previous__SWIG_0(int argc, VALUE *argv, VALUE self) {
+  swig::Iterator *arg1 = (swig::Iterator *) 0 ;
+  size_t arg2 ;
+  void *argp1 = 0 ;
+  int res1 = 0 ;
+  size_t val2 ;
+  int ecode2 = 0 ;
+  swig::Iterator *result = 0 ;
+  VALUE vresult = Qnil;
+  
+  if ((argc < 1) || (argc > 1)) {
+    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc); SWIG_fail;
+  }
+  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_swig__Iterator, 0 |  0 );
+  if (!SWIG_IsOK(res1)) {
+    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "swig::Iterator *","previous", 1, self )); 
+  }
+  arg1 = reinterpret_cast< swig::Iterator * >(argp1);
+  ecode2 = SWIG_AsVal_size_t(argv[0], &val2);
+  if (!SWIG_IsOK(ecode2)) {
+    SWIG_exception_fail(SWIG_ArgError(ecode2), Ruby_Format_TypeError( "", "size_t","previous", 2, argv[0] ));
+  } 
+  arg2 = static_cast< size_t >(val2);
+  result = (swig::Iterator *)(arg1)->previous(arg2);
+  vresult = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_swig__Iterator, 0 |  0 );
+  return vresult;
+fail:
+  return Qnil;
+}
+
+
+SWIGINTERN VALUE
+_wrap_Iterator_previous__SWIG_1(int argc, VALUE *argv, VALUE self) {
+  swig::Iterator *arg1 = (swig::Iterator *) 0 ;
+  void *argp1 = 0 ;
+  int res1 = 0 ;
+  swig::Iterator *result = 0 ;
+  VALUE vresult = Qnil;
+  
+  if ((argc < 0) || (argc > 0)) {
+    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;
+  }
+  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_swig__Iterator, 0 |  0 );
+  if (!SWIG_IsOK(res1)) {
+    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "swig::Iterator *","previous", 1, self )); 
+  }
+  arg1 = reinterpret_cast< swig::Iterator * >(argp1);
+  try {
+    result = (swig::Iterator *)(arg1)->previous();
+  }
+  catch(swig::stop_iteration &_e) {
+    {
+      (void)_e;
+      SWIG_Ruby_ExceptionType(NULL, Qnil);
+      SWIG_fail;
+    }
+  }
+  
+  vresult = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_swig__Iterator, 0 |  0 );
+  return vresult;
+fail:
+  return Qnil;
+}
+
+
+SWIGINTERN VALUE _wrap_Iterator_previous(int nargs, VALUE *args, VALUE self) {
+  int argc;
+  VALUE argv[3];
+  int ii;
+  
+  argc = nargs + 1;
+  argv[0] = self;
+  if (argc > 3) SWIG_fail;
+  for (ii = 1; (ii < argc); ++ii) {
+    argv[ii] = args[ii-1];
+  }
+  if (argc == 1) {
+    int _v;
+    void *vptr = 0;
+    int res = SWIG_ConvertPtr(argv[0], &vptr, SWIGTYPE_p_swig__Iterator, 0);
+    _v = SWIG_CheckState(res);
+    if (_v) {
+      return _wrap_Iterator_previous__SWIG_1(nargs, args, self);
+    }
+  }
+  if (argc == 2) {
+    int _v;
+    void *vptr = 0;
+    int res = SWIG_ConvertPtr(argv[0], &vptr, SWIGTYPE_p_swig__Iterator, 0);
+    _v = SWIG_CheckState(res);
+    if (_v) {
+      {
+        int res = SWIG_AsVal_size_t(argv[1], NULL);
+        _v = SWIG_CheckState(res);
+      }
+      if (_v) {
+        return _wrap_Iterator_previous__SWIG_0(nargs, args, self);
+      }
+    }
+  }
+  
+fail:
+  Ruby_Format_OverloadedError( argc, 3, "Iterator.previous", 
+    "    swig::Iterator * Iterator.previous(size_t n)\n"
+    "    swig::Iterator * Iterator.previous()\n");
+  
+  return Qnil;
+}
+
+
+
+/*
+  Document-method: Geos::Iterator.inspect
+
+  call-seq:
+    inspect -> VALUE
+
+Inspect class and its contents.
+*/
+SWIGINTERN VALUE
+_wrap_Iterator_inspect(int argc, VALUE *argv, VALUE self) {
+  swig::Iterator *arg1 = (swig::Iterator *) 0 ;
+  void *argp1 = 0 ;
+  int res1 = 0 ;
+  VALUE result;
+  VALUE vresult = Qnil;
+  
+  if ((argc < 0) || (argc > 0)) {
+    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;
+  }
+  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_swig__Iterator, 0 |  0 );
+  if (!SWIG_IsOK(res1)) {
+    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "swig::Iterator const *","inspect", 1, self )); 
+  }
+  arg1 = reinterpret_cast< swig::Iterator * >(argp1);
+  result = (VALUE)((swig::Iterator const *)arg1)->inspect();
+  vresult = result;
+  return vresult;
+fail:
+  return Qnil;
+}
+
+
+
+/*
+  Document-method: Geos::Iterator.to_s
+
+  call-seq:
+    to_s -> VALUE
+
+Convert class to a String representation.
+*/
+SWIGINTERN VALUE
+_wrap_Iterator_to_s(int argc, VALUE *argv, VALUE self) {
+  swig::Iterator *arg1 = (swig::Iterator *) 0 ;
+  void *argp1 = 0 ;
+  int res1 = 0 ;
+  VALUE result;
+  VALUE vresult = Qnil;
+  
+  if ((argc < 0) || (argc > 0)) {
+    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;
+  }
+  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_swig__Iterator, 0 |  0 );
+  if (!SWIG_IsOK(res1)) {
+    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "swig::Iterator const *","to_s", 1, self )); 
+  }
+  arg1 = reinterpret_cast< swig::Iterator * >(argp1);
+  result = (VALUE)((swig::Iterator const *)arg1)->to_s();
+  vresult = result;
+  return vresult;
+fail:
+  return Qnil;
+}
+
+
+
+/*
+  Document-method: Geos::Iterator.==
+
+  call-seq:
+    ==(x) -> bool
+
+Equality comparison operator.
+*/
+SWIGINTERN VALUE
+_wrap_Iterator___eq__(int argc, VALUE *argv, VALUE self) {
+  swig::Iterator *arg1 = (swig::Iterator *) 0 ;
+  swig::Iterator *arg2 = 0 ;
+  void *argp1 = 0 ;
+  int res1 = 0 ;
+  void *argp2 ;
+  int res2 = 0 ;
+  bool result;
+  VALUE vresult = Qnil;
+  
+  if ((argc < 1) || (argc > 1)) {
+    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc); SWIG_fail;
+  }
+  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_swig__Iterator, 0 |  0 );
+  if (!SWIG_IsOK(res1)) {
+    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "swig::Iterator const *","operator ==", 1, self )); 
+  }
+  arg1 = reinterpret_cast< swig::Iterator * >(argp1);
+  res2 = SWIG_ConvertPtr(argv[0], &argp2, SWIGTYPE_p_swig__Iterator,  0 );
+  if (!SWIG_IsOK(res2)) {
+    SWIG_exception_fail(SWIG_ArgError(res2), Ruby_Format_TypeError( "", "swig::Iterator const &","operator ==", 2, argv[0] )); 
+  }
+  if (!argp2) {
+    SWIG_exception_fail(SWIG_ValueError, Ruby_Format_TypeError("invalid null reference ", "swig::Iterator const &","operator ==", 2, argv[0])); 
+  }
+  arg2 = reinterpret_cast< swig::Iterator * >(argp2);
+  result = (bool)((swig::Iterator const *)arg1)->operator ==((swig::Iterator const &)*arg2);
+  vresult = SWIG_From_bool(static_cast< bool >(result));
+  return vresult;
+fail:
+  return Qnil;
+}
+
+
+
+/*
+  Document-method: Geos::Iterator.+
+
+  call-seq:
+    +(n) -> Iterator
+
+Add operator.
+*/
+SWIGINTERN VALUE
+_wrap_Iterator___add__(int argc, VALUE *argv, VALUE self) {
+  swig::Iterator *arg1 = (swig::Iterator *) 0 ;
+  ptrdiff_t arg2 ;
+  void *argp1 = 0 ;
+  int res1 = 0 ;
+  ptrdiff_t val2 ;
+  int ecode2 = 0 ;
+  swig::Iterator *result = 0 ;
+  VALUE vresult = Qnil;
+  
+  if ((argc < 1) || (argc > 1)) {
+    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc); SWIG_fail;
+  }
+  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_swig__Iterator, 0 |  0 );
+  if (!SWIG_IsOK(res1)) {
+    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "swig::Iterator const *","operator +", 1, self )); 
+  }
+  arg1 = reinterpret_cast< swig::Iterator * >(argp1);
+  ecode2 = SWIG_AsVal_ptrdiff_t(argv[0], &val2);
+  if (!SWIG_IsOK(ecode2)) {
+    SWIG_exception_fail(SWIG_ArgError(ecode2), Ruby_Format_TypeError( "", "ptrdiff_t","operator +", 2, argv[0] ));
+  } 
+  arg2 = static_cast< ptrdiff_t >(val2);
+  try {
+    result = (swig::Iterator *)((swig::Iterator const *)arg1)->operator +(arg2);
+  }
+  catch(swig::stop_iteration &_e) {
+    {
+      (void)_e;
+      SWIG_Ruby_ExceptionType(NULL, Qnil);
+      SWIG_fail;
+    }
+  }
+  
+  vresult = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_swig__Iterator, SWIG_POINTER_OWN |  0 );
+  return vresult;
+fail:
+  return Qnil;
+}
+
+
+
+/*
+  Document-method: Geos::Iterator.-
+
+  call-seq:
+    -(n) -> Iterator
+    -(x) -> ptrdiff_t
+
+Substraction operator.
+*/
+SWIGINTERN VALUE
+_wrap_Iterator___sub____SWIG_0(int argc, VALUE *argv, VALUE self) {
+  swig::Iterator *arg1 = (swig::Iterator *) 0 ;
+  ptrdiff_t arg2 ;
+  void *argp1 = 0 ;
+  int res1 = 0 ;
+  ptrdiff_t val2 ;
+  int ecode2 = 0 ;
+  swig::Iterator *result = 0 ;
+  VALUE vresult = Qnil;
+  
+  if ((argc < 1) || (argc > 1)) {
+    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc); SWIG_fail;
+  }
+  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_swig__Iterator, 0 |  0 );
+  if (!SWIG_IsOK(res1)) {
+    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "swig::Iterator const *","operator -", 1, self )); 
+  }
+  arg1 = reinterpret_cast< swig::Iterator * >(argp1);
+  ecode2 = SWIG_AsVal_ptrdiff_t(argv[0], &val2);
+  if (!SWIG_IsOK(ecode2)) {
+    SWIG_exception_fail(SWIG_ArgError(ecode2), Ruby_Format_TypeError( "", "ptrdiff_t","operator -", 2, argv[0] ));
+  } 
+  arg2 = static_cast< ptrdiff_t >(val2);
+  try {
+    result = (swig::Iterator *)((swig::Iterator const *)arg1)->operator -(arg2);
+  }
+  catch(swig::stop_iteration &_e) {
+    {
+      (void)_e;
+      SWIG_Ruby_ExceptionType(NULL, Qnil);
+      SWIG_fail;
+    }
+  }
+  
+  vresult = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_swig__Iterator, SWIG_POINTER_OWN |  0 );
+  return vresult;
+fail:
+  return Qnil;
+}
+
+
+SWIGINTERN VALUE
+_wrap_Iterator___sub____SWIG_1(int argc, VALUE *argv, VALUE self) {
+  swig::Iterator *arg1 = (swig::Iterator *) 0 ;
+  swig::Iterator *arg2 = 0 ;
+  void *argp1 = 0 ;
+  int res1 = 0 ;
+  void *argp2 ;
+  int res2 = 0 ;
+  ptrdiff_t result;
+  VALUE vresult = Qnil;
+  
+  if ((argc < 1) || (argc > 1)) {
+    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc); SWIG_fail;
+  }
+  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_swig__Iterator, 0 |  0 );
+  if (!SWIG_IsOK(res1)) {
+    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "swig::Iterator const *","operator -", 1, self )); 
+  }
+  arg1 = reinterpret_cast< swig::Iterator * >(argp1);
+  res2 = SWIG_ConvertPtr(argv[0], &argp2, SWIGTYPE_p_swig__Iterator,  0 );
+  if (!SWIG_IsOK(res2)) {
+    SWIG_exception_fail(SWIG_ArgError(res2), Ruby_Format_TypeError( "", "swig::Iterator const &","operator -", 2, argv[0] )); 
+  }
+  if (!argp2) {
+    SWIG_exception_fail(SWIG_ValueError, Ruby_Format_TypeError("invalid null reference ", "swig::Iterator const &","operator -", 2, argv[0])); 
+  }
+  arg2 = reinterpret_cast< swig::Iterator * >(argp2);
+  result = ((swig::Iterator const *)arg1)->operator -((swig::Iterator const &)*arg2);
+  vresult = SWIG_From_ptrdiff_t(static_cast< ptrdiff_t >(result));
+  return vresult;
+fail:
+  return Qnil;
+}
+
+
+SWIGINTERN VALUE _wrap_Iterator___sub__(int nargs, VALUE *args, VALUE self) {
+  int argc;
+  VALUE argv[3];
+  int ii;
+  
+  argc = nargs + 1;
+  argv[0] = self;
+  if (argc > 3) SWIG_fail;
+  for (ii = 1; (ii < argc); ++ii) {
+    argv[ii] = args[ii-1];
+  }
+  if (argc == 2) {
+    int _v;
+    void *vptr = 0;
+    int res = SWIG_ConvertPtr(argv[0], &vptr, SWIGTYPE_p_swig__Iterator, 0);
+    _v = SWIG_CheckState(res);
+    if (_v) {
+      void *vptr = 0;
+      int res = SWIG_ConvertPtr(argv[1], &vptr, SWIGTYPE_p_swig__Iterator, 0);
+      _v = SWIG_CheckState(res);
+      if (_v) {
+        return _wrap_Iterator___sub____SWIG_1(nargs, args, self);
+      }
+    }
+  }
+  if (argc == 2) {
+    int _v;
+    void *vptr = 0;
+    int res = SWIG_ConvertPtr(argv[0], &vptr, SWIGTYPE_p_swig__Iterator, 0);
+    _v = SWIG_CheckState(res);
+    if (_v) {
+      {
+        int res = SWIG_AsVal_ptrdiff_t(argv[1], NULL);
+        _v = SWIG_CheckState(res);
+      }
+      if (_v) {
+        return _wrap_Iterator___sub____SWIG_0(nargs, args, self);
+      }
+    }
+  }
+  
+fail:
+  Ruby_Format_OverloadedError( argc, 3, "__sub__.new", 
+    "    __sub__.new(ptrdiff_t n)\n"
+    "    __sub__.new(swig::Iterator const &x)\n");
+  
+  return Qnil;
+}
+
+
+SWIGINTERN void
+free_swig_Iterator(swig::Iterator *arg1) {
+    delete arg1;
+}
+
 SWIGINTERN VALUE
 _wrap_version(int argc, VALUE *argv, VALUE self) {
   char *result = 0 ;
@@ -2458,7 +4598,7 @@
 }
 
 
-swig_class cCoordinateSequence;
+swig_class SwigClassCoordinateSequence;
 
 #ifdef HAVE_RB_DEFINE_ALLOC_FUNC
 SWIGINTERN VALUE
@@ -2481,30 +4621,30 @@
 _wrap_new_CoordinateSequence(int argc, VALUE *argv, VALUE self) {
   size_t arg1 ;
   size_t arg2 ;
-  GeosCoordinateSequence *result = 0 ;
   size_t val1 ;
   int ecode1 = 0 ;
   size_t val2 ;
   int ecode2 = 0 ;
+  GeosCoordinateSequence *result = 0 ;
   
   if ((argc < 2) || (argc > 2)) {
     rb_raise(rb_eArgError, "wrong # of arguments(%d for 2)",argc); SWIG_fail;
   }
   ecode1 = SWIG_AsVal_size_t(argv[0], &val1);
   if (!SWIG_IsOK(ecode1)) {
-    SWIG_exception_fail(SWIG_ArgError(ecode1), "in method '" "GeosCoordinateSequence" "', argument " "1"" of type '" "size_t""'");
+    SWIG_exception_fail(SWIG_ArgError(ecode1), Ruby_Format_TypeError( "", "size_t","GeosCoordinateSequence", 1, argv[0] ));
   } 
   arg1 = static_cast< size_t >(val1);
   ecode2 = SWIG_AsVal_size_t(argv[1], &val2);
   if (!SWIG_IsOK(ecode2)) {
-    SWIG_exception_fail(SWIG_ArgError(ecode2), "in method '" "GeosCoordinateSequence" "', argument " "2"" of type '" "size_t""'");
+    SWIG_exception_fail(SWIG_ArgError(ecode2), Ruby_Format_TypeError( "", "size_t","GeosCoordinateSequence", 2, argv[1] ));
   } 
   arg2 = static_cast< size_t >(val2);
   {
     try
     {
-      result = (GeosCoordinateSequence *)new_GeosCoordinateSequence(arg1,arg2);DATA_PTR(self) = result;
-      
+      result = (GeosCoordinateSequence *)new_GeosCoordinateSequence(arg1,arg2);
+      DATA_PTR(self) = result;
     }
     catch (const std::exception& e)
     {
@@ -2526,12 +4666,21 @@
     delete_GeosCoordinateSequence(arg1);
 }
 
+
+/*
+  Document-method: Geos::CoordinateSequence.clone
+
+  call-seq:
+    clone -> CoordinateSequence
+
+Create a duplicate of the class.
+*/
 SWIGINTERN VALUE
 _wrap_CoordinateSequence_clone(int argc, VALUE *argv, VALUE self) {
   GeosCoordinateSequence *arg1 = (GeosCoordinateSequence *) 0 ;
-  GeosCoordinateSequence *result = 0 ;
   void *argp1 = 0 ;
   int res1 = 0 ;
+  GeosCoordinateSequence *result = 0 ;
   VALUE vresult = Qnil;
   
   if ((argc < 0) || (argc > 0)) {
@@ -2539,7 +4688,7 @@
   }
   res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_GeosCoordinateSequence, 0 |  0 );
   if (!SWIG_IsOK(res1)) {
-    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "clone" "', argument " "1"" of type '" "GeosCoordinateSequence *""'"); 
+    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "GeosCoordinateSequence *","clone", 1, self )); 
   }
   arg1 = reinterpret_cast< GeosCoordinateSequence * >(argp1);
   {
@@ -2564,13 +4713,13 @@
   GeosCoordinateSequence *arg1 = (GeosCoordinateSequence *) 0 ;
   size_t arg2 ;
   double arg3 ;
-  int result;
   void *argp1 = 0 ;
   int res1 = 0 ;
   size_t val2 ;
   int ecode2 = 0 ;
   double val3 ;
   int ecode3 = 0 ;
+  int result;
   VALUE vresult = Qnil;
   
   if ((argc < 2) || (argc > 2)) {
@@ -2578,17 +4727,17 @@
   }
   res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_GeosCoordinateSequence, 0 |  0 );
   if (!SWIG_IsOK(res1)) {
-    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "setX" "', argument " "1"" of type '" "GeosCoordinateSequence *""'"); 
+    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "GeosCoordinateSequence *","setX", 1, self )); 
   }
   arg1 = reinterpret_cast< GeosCoordinateSequence * >(argp1);
   ecode2 = SWIG_AsVal_size_t(argv[0], &val2);
   if (!SWIG_IsOK(ecode2)) {
-    SWIG_exception_fail(SWIG_ArgError(ecode2), "in method '" "setX" "', argument " "2"" of type '" "size_t""'");
+    SWIG_exception_fail(SWIG_ArgError(ecode2), Ruby_Format_TypeError( "", "size_t","setX", 2, argv[0] ));
   } 
   arg2 = static_cast< size_t >(val2);
   ecode3 = SWIG_AsVal_double(argv[1], &val3);
   if (!SWIG_IsOK(ecode3)) {
-    SWIG_exception_fail(SWIG_ArgError(ecode3), "in method '" "setX" "', argument " "3"" of type '" "double""'");
+    SWIG_exception_fail(SWIG_ArgError(ecode3), Ruby_Format_TypeError( "", "double","setX", 3, argv[1] ));
   } 
   arg3 = static_cast< double >(val3);
   {
@@ -2613,13 +4762,13 @@
   GeosCoordinateSequence *arg1 = (GeosCoordinateSequence *) 0 ;
   size_t arg2 ;
   double arg3 ;
-  int result;
   void *argp1 = 0 ;
   int res1 = 0 ;
   size_t val2 ;
   int ecode2 = 0 ;
   double val3 ;
   int ecode3 = 0 ;
+  int result;
   VALUE vresult = Qnil;
   
   if ((argc < 2) || (argc > 2)) {
@@ -2627,17 +4776,17 @@
   }
   res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_GeosCoordinateSequence, 0 |  0 );
   if (!SWIG_IsOK(res1)) {
-    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "setY" "', argument " "1"" of type '" "GeosCoordinateSequence *""'"); 
+    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "GeosCoordinateSequence *","setY", 1, self )); 
   }
   arg1 = reinterpret_cast< GeosCoordinateSequence * >(argp1);
   ecode2 = SWIG_AsVal_size_t(argv[0], &val2);
   if (!SWIG_IsOK(ecode2)) {
-    SWIG_exception_fail(SWIG_ArgError(ecode2), "in method '" "setY" "', argument " "2"" of type '" "size_t""'");
+    SWIG_exception_fail(SWIG_ArgError(ecode2), Ruby_Format_TypeError( "", "size_t","setY", 2, argv[0] ));
   } 
   arg2 = static_cast< size_t >(val2);
   ecode3 = SWIG_AsVal_double(argv[1], &val3);
   if (!SWIG_IsOK(ecode3)) {
-    SWIG_exception_fail(SWIG_ArgError(ecode3), "in method '" "setY" "', argument " "3"" of type '" "double""'");
+    SWIG_exception_fail(SWIG_ArgError(ecode3), Ruby_Format_TypeError( "", "double","setY", 3, argv[1] ));
   } 
   arg3 = static_cast< double >(val3);
   {
@@ -2662,13 +4811,13 @@
   GeosCoordinateSequence *arg1 = (GeosCoordinateSequence *) 0 ;
   size_t arg2 ;
   double arg3 ;
-  int result;
   void *argp1 = 0 ;
   int res1 = 0 ;
   size_t val2 ;
   int ecode2 = 0 ;
   double val3 ;
   int ecode3 = 0 ;
+  int result;
   VALUE vresult = Qnil;
   
   if ((argc < 2) || (argc > 2)) {
@@ -2676,17 +4825,17 @@
   }
   res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_GeosCoordinateSequence, 0 |  0 );
   if (!SWIG_IsOK(res1)) {
-    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "setZ" "', argument " "1"" of type '" "GeosCoordinateSequence *""'"); 
+    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "GeosCoordinateSequence *","setZ", 1, self )); 
   }
   arg1 = reinterpret_cast< GeosCoordinateSequence * >(argp1);
   ecode2 = SWIG_AsVal_size_t(argv[0], &val2);
   if (!SWIG_IsOK(ecode2)) {
-    SWIG_exception_fail(SWIG_ArgError(ecode2), "in method '" "setZ" "', argument " "2"" of type '" "size_t""'");
+    SWIG_exception_fail(SWIG_ArgError(ecode2), Ruby_Format_TypeError( "", "size_t","setZ", 2, argv[0] ));
   } 
   arg2 = static_cast< size_t >(val2);
   ecode3 = SWIG_AsVal_double(argv[1], &val3);
   if (!SWIG_IsOK(ecode3)) {
-    SWIG_exception_fail(SWIG_ArgError(ecode3), "in method '" "setZ" "', argument " "3"" of type '" "double""'");
+    SWIG_exception_fail(SWIG_ArgError(ecode3), Ruby_Format_TypeError( "", "double","setZ", 3, argv[1] ));
   } 
   arg3 = static_cast< double >(val3);
   {
@@ -2712,7 +4861,6 @@
   size_t arg2 ;
   size_t arg3 ;
   double arg4 ;
-  int result;
   void *argp1 = 0 ;
   int res1 = 0 ;
   size_t val2 ;
@@ -2721,6 +4869,7 @@
   int ecode3 = 0 ;
   double val4 ;
   int ecode4 = 0 ;
+  int result;
   VALUE vresult = Qnil;
   
   if ((argc < 3) || (argc > 3)) {
@@ -2728,22 +4877,22 @@
   }
   res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_GeosCoordinateSequence, 0 |  0 );
   if (!SWIG_IsOK(res1)) {
-    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "setOrdinate" "', argument " "1"" of type '" "GeosCoordinateSequence *""'"); 
+    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "GeosCoordinateSequence *","setOrdinate", 1, self )); 
   }
   arg1 = reinterpret_cast< GeosCoordinateSequence * >(argp1);
   ecode2 = SWIG_AsVal_size_t(argv[0], &val2);
   if (!SWIG_IsOK(ecode2)) {
-    SWIG_exception_fail(SWIG_ArgError(ecode2), "in method '" "setOrdinate" "', argument " "2"" of type '" "size_t""'");
+    SWIG_exception_fail(SWIG_ArgError(ecode2), Ruby_Format_TypeError( "", "size_t","setOrdinate", 2, argv[0] ));
   } 
   arg2 = static_cast< size_t >(val2);
   ecode3 = SWIG_AsVal_size_t(argv[1], &val3);
   if (!SWIG_IsOK(ecode3)) {
-    SWIG_exception_fail(SWIG_ArgError(ecode3), "in method '" "setOrdinate" "', argument " "3"" of type '" "size_t""'");
+    SWIG_exception_fail(SWIG_ArgError(ecode3), Ruby_Format_TypeError( "", "size_t","setOrdinate", 3, argv[1] ));
   } 
   arg3 = static_cast< size_t >(val3);
   ecode4 = SWIG_AsVal_double(argv[2], &val4);
   if (!SWIG_IsOK(ecode4)) {
-    SWIG_exception_fail(SWIG_ArgError(ecode4), "in method '" "setOrdinate" "', argument " "4"" of type '" "double""'");
+    SWIG_exception_fail(SWIG_ArgError(ecode4), Ruby_Format_TypeError( "", "double","setOrdinate", 4, argv[2] ));
   } 
   arg4 = static_cast< double >(val4);
   {
@@ -2767,11 +4916,11 @@
 _wrap_CoordinateSequence_get_x(int argc, VALUE *argv, VALUE self) {
   GeosCoordinateSequence *arg1 = (GeosCoordinateSequence *) 0 ;
   size_t arg2 ;
-  double result;
   void *argp1 = 0 ;
   int res1 = 0 ;
   size_t val2 ;
   int ecode2 = 0 ;
+  double result;
   VALUE vresult = Qnil;
   
   if ((argc < 1) || (argc > 1)) {
@@ -2779,12 +4928,12 @@
   }
   res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_GeosCoordinateSequence, 0 |  0 );
   if (!SWIG_IsOK(res1)) {
-    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "getX" "', argument " "1"" of type '" "GeosCoordinateSequence *""'"); 
+    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "GeosCoordinateSequence *","getX", 1, self )); 
   }
   arg1 = reinterpret_cast< GeosCoordinateSequence * >(argp1);
   ecode2 = SWIG_AsVal_size_t(argv[0], &val2);
   if (!SWIG_IsOK(ecode2)) {
-    SWIG_exception_fail(SWIG_ArgError(ecode2), "in method '" "getX" "', argument " "2"" of type '" "size_t""'");
+    SWIG_exception_fail(SWIG_ArgError(ecode2), Ruby_Format_TypeError( "", "size_t","getX", 2, argv[0] ));
   } 
   arg2 = static_cast< size_t >(val2);
   {
@@ -2808,11 +4957,11 @@
 _wrap_CoordinateSequence_get_y(int argc, VALUE *argv, VALUE self) {
   GeosCoordinateSequence *arg1 = (GeosCoordinateSequence *) 0 ;
   size_t arg2 ;
-  double result;
   void *argp1 = 0 ;
   int res1 = 0 ;
   size_t val2 ;
   int ecode2 = 0 ;
+  double result;
   VALUE vresult = Qnil;
   
   if ((argc < 1) || (argc > 1)) {
@@ -2820,12 +4969,12 @@
   }
   res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_GeosCoordinateSequence, 0 |  0 );
   if (!SWIG_IsOK(res1)) {
-    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "getY" "', argument " "1"" of type '" "GeosCoordinateSequence *""'"); 
+    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "GeosCoordinateSequence *","getY", 1, self )); 
   }
   arg1 = reinterpret_cast< GeosCoordinateSequence * >(argp1);
   ecode2 = SWIG_AsVal_size_t(argv[0], &val2);
   if (!SWIG_IsOK(ecode2)) {
-    SWIG_exception_fail(SWIG_ArgError(ecode2), "in method '" "getY" "', argument " "2"" of type '" "size_t""'");
+    SWIG_exception_fail(SWIG_ArgError(ecode2), Ruby_Format_TypeError( "", "size_t","getY", 2, argv[0] ));
   } 
   arg2 = static_cast< size_t >(val2);
   {
@@ -2849,11 +4998,11 @@
 _wrap_CoordinateSequence_get_z(int argc, VALUE *argv, VALUE self) {
   GeosCoordinateSequence *arg1 = (GeosCoordinateSequence *) 0 ;
   size_t arg2 ;
-  double result;
   void *argp1 = 0 ;
   int res1 = 0 ;
   size_t val2 ;
   int ecode2 = 0 ;
+  double result;
   VALUE vresult = Qnil;
   
   if ((argc < 1) || (argc > 1)) {
@@ -2861,12 +5010,12 @@
   }
   res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_GeosCoordinateSequence, 0 |  0 );
   if (!SWIG_IsOK(res1)) {
-    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "getZ" "', argument " "1"" of type '" "GeosCoordinateSequence *""'"); 
+    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "GeosCoordinateSequence *","getZ", 1, self )); 
   }
   arg1 = reinterpret_cast< GeosCoordinateSequence * >(argp1);
   ecode2 = SWIG_AsVal_size_t(argv[0], &val2);
   if (!SWIG_IsOK(ecode2)) {
-    SWIG_exception_fail(SWIG_ArgError(ecode2), "in method '" "getZ" "', argument " "2"" of type '" "size_t""'");
+    SWIG_exception_fail(SWIG_ArgError(ecode2), Ruby_Format_TypeError( "", "size_t","getZ", 2, argv[0] ));
   } 
   arg2 = static_cast< size_t >(val2);
   {
@@ -2891,13 +5040,13 @@
   GeosCoordinateSequence *arg1 = (GeosCoordinateSequence *) 0 ;
   size_t arg2 ;
   size_t arg3 ;
-  double result;
   void *argp1 = 0 ;
   int res1 = 0 ;
   size_t val2 ;
   int ecode2 = 0 ;
   size_t val3 ;
   int ecode3 = 0 ;
+  double result;
   VALUE vresult = Qnil;
   
   if ((argc < 2) || (argc > 2)) {
@@ -2905,17 +5054,17 @@
   }
   res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_GeosCoordinateSequence, 0 |  0 );
   if (!SWIG_IsOK(res1)) {
-    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "getOrdinate" "', argument " "1"" of type '" "GeosCoordinateSequence *""'"); 
+    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "GeosCoordinateSequence *","getOrdinate", 1, self )); 
   }
   arg1 = reinterpret_cast< GeosCoordinateSequence * >(argp1);
   ecode2 = SWIG_AsVal_size_t(argv[0], &val2);
   if (!SWIG_IsOK(ecode2)) {
-    SWIG_exception_fail(SWIG_ArgError(ecode2), "in method '" "getOrdinate" "', argument " "2"" of type '" "size_t""'");
+    SWIG_exception_fail(SWIG_ArgError(ecode2), Ruby_Format_TypeError( "", "size_t","getOrdinate", 2, argv[0] ));
   } 
   arg2 = static_cast< size_t >(val2);
   ecode3 = SWIG_AsVal_size_t(argv[1], &val3);
   if (!SWIG_IsOK(ecode3)) {
-    SWIG_exception_fail(SWIG_ArgError(ecode3), "in method '" "getOrdinate" "', argument " "3"" of type '" "size_t""'");
+    SWIG_exception_fail(SWIG_ArgError(ecode3), Ruby_Format_TypeError( "", "size_t","getOrdinate", 3, argv[1] ));
   } 
   arg3 = static_cast< size_t >(val3);
   {
@@ -2938,9 +5087,9 @@
 SWIGINTERN VALUE
 _wrap_CoordinateSequence___len__(int argc, VALUE *argv, VALUE self) {
   GeosCoordinateSequence *arg1 = (GeosCoordinateSequence *) 0 ;
-  unsigned int result;
   void *argp1 = 0 ;
   int res1 = 0 ;
+  unsigned int result;
   VALUE vresult = Qnil;
   
   if ((argc < 0) || (argc > 0)) {
@@ -2948,7 +5097,7 @@
   }
   res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_GeosCoordinateSequence, 0 |  0 );
   if (!SWIG_IsOK(res1)) {
-    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "getSize" "', argument " "1"" of type '" "GeosCoordinateSequence *""'"); 
+    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "GeosCoordinateSequence *","getSize", 1, self )); 
   }
   arg1 = reinterpret_cast< GeosCoordinateSequence * >(argp1);
   {
@@ -2971,9 +5120,9 @@
 SWIGINTERN VALUE
 _wrap_CoordinateSequence_dimensions(int argc, VALUE *argv, VALUE self) {
   GeosCoordinateSequence *arg1 = (GeosCoordinateSequence *) 0 ;
-  unsigned int result;
   void *argp1 = 0 ;
   int res1 = 0 ;
+  unsigned int result;
   VALUE vresult = Qnil;
   
   if ((argc < 0) || (argc > 0)) {
@@ -2981,7 +5130,7 @@
   }
   res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_GeosCoordinateSequence, 0 |  0 );
   if (!SWIG_IsOK(res1)) {
-    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "getDimensions" "', argument " "1"" of type '" "GeosCoordinateSequence *""'"); 
+    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "GeosCoordinateSequence *","getDimensions", 1, self )); 
   }
   arg1 = reinterpret_cast< GeosCoordinateSequence * >(argp1);
   {
@@ -3001,7 +5150,7 @@
 }
 
 
-swig_class cGeometry;
+swig_class SwigClassGeometry;
 
 SWIGINTERN void delete_GeosGeometry(GeosGeometry *self){
         GEOSGeom geom = (GEOSGeom) self;
@@ -3012,12 +5161,21 @@
     delete_GeosGeometry(arg1);
 }
 
+
+/*
+  Document-method: Geos::Geometry.clone
+
+  call-seq:
+    clone -> Geometry
+
+Create a duplicate of the class.
+*/
 SWIGINTERN VALUE
 _wrap_Geometry_clone(int argc, VALUE *argv, VALUE self) {
   GeosGeometry *arg1 = (GeosGeometry *) 0 ;
-  GeosGeometry *result = 0 ;
   void *argp1 = 0 ;
   int res1 = 0 ;
+  GeosGeometry *result = 0 ;
   VALUE vresult = Qnil;
   
   if ((argc < 0) || (argc > 0)) {
@@ -3025,7 +5183,7 @@
   }
   res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_GeosGeometry, 0 |  0 );
   if (!SWIG_IsOK(res1)) {
-    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "clone" "', argument " "1"" of type '" "GeosGeometry *""'"); 
+    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "GeosGeometry *","clone", 1, self )); 
   }
   arg1 = reinterpret_cast< GeosGeometry * >(argp1);
   {
@@ -3084,9 +5242,9 @@
 SWIGINTERN VALUE
 _wrap_Geometry_geom_type(int argc, VALUE *argv, VALUE self) {
   GeosGeometry *arg1 = (GeosGeometry *) 0 ;
-  char *result = 0 ;
   void *argp1 = 0 ;
   int res1 = 0 ;
+  char *result = 0 ;
   VALUE vresult = Qnil;
   
   if ((argc < 0) || (argc > 0)) {
@@ -3094,7 +5252,7 @@
   }
   res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_GeosGeometry, 0 |  0 );
   if (!SWIG_IsOK(res1)) {
-    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "geomType" "', argument " "1"" of type '" "GeosGeometry *""'"); 
+    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "GeosGeometry *","geomType", 1, self )); 
   }
   arg1 = reinterpret_cast< GeosGeometry * >(argp1);
   {
@@ -3117,9 +5275,9 @@
 SWIGINTERN VALUE
 _wrap_Geometry_type_id(int argc, VALUE *argv, VALUE self) {
   GeosGeometry *arg1 = (GeosGeometry *) 0 ;
-  int result;
   void *argp1 = 0 ;
   int res1 = 0 ;
+  int result;
   VALUE vresult = Qnil;
   
   if ((argc < 0) || (argc > 0)) {
@@ -3127,7 +5285,7 @@
   }
   res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_GeosGeometry, 0 |  0 );
   if (!SWIG_IsOK(res1)) {
-    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "typeId" "', argument " "1"" of type '" "GeosGeometry *""'"); 
+    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "GeosGeometry *","typeId", 1, self )); 
   }
   arg1 = reinterpret_cast< GeosGeometry * >(argp1);
   {
@@ -3158,7 +5316,7 @@
   }
   res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_GeosGeometry, 0 |  0 );
   if (!SWIG_IsOK(res1)) {
-    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "normalize" "', argument " "1"" of type '" "GeosGeometry *""'"); 
+    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "GeosGeometry *","normalize", 1, self )); 
   }
   arg1 = reinterpret_cast< GeosGeometry * >(argp1);
   {
@@ -3180,9 +5338,9 @@
 SWIGINTERN VALUE
 _wrap_Geometry_srid(int argc, VALUE *argv, VALUE self) {
   GeosGeometry *arg1 = (GeosGeometry *) 0 ;
-  int result;
   void *argp1 = 0 ;
   int res1 = 0 ;
+  int result;
   VALUE vresult = Qnil;
   
   if ((argc < 0) || (argc > 0)) {
@@ -3190,7 +5348,7 @@
   }
   res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_GeosGeometry, 0 |  0 );
   if (!SWIG_IsOK(res1)) {
-    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "getSRID" "', argument " "1"" of type '" "GeosGeometry *""'"); 
+    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "GeosGeometry *","getSRID", 1, self )); 
   }
   arg1 = reinterpret_cast< GeosGeometry * >(argp1);
   {
@@ -3224,12 +5382,12 @@
   }
   res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_GeosGeometry, 0 |  0 );
   if (!SWIG_IsOK(res1)) {
-    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "setSRID" "', argument " "1"" of type '" "GeosGeometry *""'"); 
+    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "GeosGeometry *","setSRID", 1, self )); 
   }
   arg1 = reinterpret_cast< GeosGeometry * >(argp1);
   ecode2 = SWIG_AsVal_int(argv[0], &val2);
   if (!SWIG_IsOK(ecode2)) {
-    SWIG_exception_fail(SWIG_ArgError(ecode2), "in method '" "setSRID" "', argument " "2"" of type '" "int""'");
+    SWIG_exception_fail(SWIG_ArgError(ecode2), Ruby_Format_TypeError( "", "int","setSRID", 2, argv[0] ));
   } 
   arg2 = static_cast< int >(val2);
   {
@@ -3251,9 +5409,9 @@
 SWIGINTERN VALUE
 _wrap_Geometry_dimensions(int argc, VALUE *argv, VALUE self) {
   GeosGeometry *arg1 = (GeosGeometry *) 0 ;
-  size_t result;
   void *argp1 = 0 ;
   int res1 = 0 ;
+  size_t result;
   VALUE vresult = Qnil;
   
   if ((argc < 0) || (argc > 0)) {
@@ -3261,7 +5419,7 @@
   }
   res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_GeosGeometry, 0 |  0 );
   if (!SWIG_IsOK(res1)) {
-    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "getDimensions" "', argument " "1"" of type '" "GeosGeometry *""'"); 
+    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "GeosGeometry *","getDimensions", 1, self )); 
   }
   arg1 = reinterpret_cast< GeosGeometry * >(argp1);
   {
@@ -3284,9 +5442,9 @@
 SWIGINTERN VALUE
 _wrap_Geometry_num_geometries(int argc, VALUE *argv, VALUE self) {
   GeosGeometry *arg1 = (GeosGeometry *) 0 ;
-  size_t result;
   void *argp1 = 0 ;
   int res1 = 0 ;
+  size_t result;
   VALUE vresult = Qnil;
   
   if ((argc < 0) || (argc > 0)) {
@@ -3294,7 +5452,7 @@
   }
   res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_GeosGeometry, 0 |  0 );
   if (!SWIG_IsOK(res1)) {
-    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "getNumGeometries" "', argument " "1"" of type '" "GeosGeometry *""'"); 
+    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "GeosGeometry *","getNumGeometries", 1, self )); 
   }
   arg1 = reinterpret_cast< GeosGeometry * >(argp1);
   {
@@ -3318,11 +5476,11 @@
 _wrap_Geometry_intersection(int argc, VALUE *argv, VALUE self) {
   GeosGeometry *arg1 = (GeosGeometry *) 0 ;
   GeosGeometry *arg2 = (GeosGeometry *) 0 ;
-  GeosGeometry *result = 0 ;
   void *argp1 = 0 ;
   int res1 = 0 ;
   void *argp2 = 0 ;
   int res2 = 0 ;
+  GeosGeometry *result = 0 ;
   VALUE vresult = Qnil;
   
   if ((argc < 1) || (argc > 1)) {
@@ -3330,12 +5488,12 @@
   }
   res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_GeosGeometry, 0 |  0 );
   if (!SWIG_IsOK(res1)) {
-    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "intersection" "', argument " "1"" of type '" "GeosGeometry *""'"); 
+    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "GeosGeometry *","intersection", 1, self )); 
   }
   arg1 = reinterpret_cast< GeosGeometry * >(argp1);
   res2 = SWIG_ConvertPtr(argv[0], &argp2,SWIGTYPE_p_GeosGeometry, 0 |  0 );
   if (!SWIG_IsOK(res2)) {
-    SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "intersection" "', argument " "2"" of type '" "GeosGeometry *""'"); 
+    SWIG_exception_fail(SWIG_ArgError(res2), Ruby_Format_TypeError( "", "GeosGeometry *","intersection", 2, argv[0] )); 
   }
   arg2 = reinterpret_cast< GeosGeometry * >(argp2);
   {
@@ -3396,13 +5554,13 @@
   GeosGeometry *arg1 = (GeosGeometry *) 0 ;
   double arg2 ;
   int arg3 ;
-  GeosGeometry *result = 0 ;
   void *argp1 = 0 ;
   int res1 = 0 ;
   double val2 ;
   int ecode2 = 0 ;
   int val3 ;
   int ecode3 = 0 ;
+  GeosGeometry *result = 0 ;
   VALUE vresult = Qnil;
   
   {
@@ -3413,18 +5571,18 @@
   }
   res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_GeosGeometry, 0 |  0 );
   if (!SWIG_IsOK(res1)) {
-    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "buffer" "', argument " "1"" of type '" "GeosGeometry *""'"); 
+    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "GeosGeometry *","buffer", 1, self )); 
   }
   arg1 = reinterpret_cast< GeosGeometry * >(argp1);
   ecode2 = SWIG_AsVal_double(argv[0], &val2);
   if (!SWIG_IsOK(ecode2)) {
-    SWIG_exception_fail(SWIG_ArgError(ecode2), "in method '" "buffer" "', argument " "2"" of type '" "double""'");
+    SWIG_exception_fail(SWIG_ArgError(ecode2), Ruby_Format_TypeError( "", "double","buffer", 2, argv[0] ));
   } 
   arg2 = static_cast< double >(val2);
   if (argc > 1) {
     ecode3 = SWIG_AsVal_int(argv[1], &val3);
     if (!SWIG_IsOK(ecode3)) {
-      SWIG_exception_fail(SWIG_ArgError(ecode3), "in method '" "buffer" "', argument " "3"" of type '" "int""'");
+      SWIG_exception_fail(SWIG_ArgError(ecode3), Ruby_Format_TypeError( "", "int","buffer", 3, argv[1] ));
     } 
     arg3 = static_cast< int >(val3);
   }
@@ -3484,9 +5642,9 @@
 SWIGINTERN VALUE
 _wrap_Geometry_convex_hull(int argc, VALUE *argv, VALUE self) {
   GeosGeometry *arg1 = (GeosGeometry *) 0 ;
-  GeosGeometry *result = 0 ;
   void *argp1 = 0 ;
   int res1 = 0 ;
+  GeosGeometry *result = 0 ;
   VALUE vresult = Qnil;
   
   if ((argc < 0) || (argc > 0)) {
@@ -3494,7 +5652,7 @@
   }
   res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_GeosGeometry, 0 |  0 );
   if (!SWIG_IsOK(res1)) {
-    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "convexHull" "', argument " "1"" of type '" "GeosGeometry *""'"); 
+    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "GeosGeometry *","convexHull", 1, self )); 
   }
   arg1 = reinterpret_cast< GeosGeometry * >(argp1);
   {
@@ -3554,11 +5712,11 @@
 _wrap_Geometry_difference(int argc, VALUE *argv, VALUE self) {
   GeosGeometry *arg1 = (GeosGeometry *) 0 ;
   GeosGeometry *arg2 = (GeosGeometry *) 0 ;
-  GeosGeometry *result = 0 ;
   void *argp1 = 0 ;
   int res1 = 0 ;
   void *argp2 = 0 ;
   int res2 = 0 ;
+  GeosGeometry *result = 0 ;
   VALUE vresult = Qnil;
   
   if ((argc < 1) || (argc > 1)) {
@@ -3566,12 +5724,12 @@
   }
   res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_GeosGeometry, 0 |  0 );
   if (!SWIG_IsOK(res1)) {
-    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "difference" "', argument " "1"" of type '" "GeosGeometry *""'"); 
+    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "GeosGeometry *","difference", 1, self )); 
   }
   arg1 = reinterpret_cast< GeosGeometry * >(argp1);
   res2 = SWIG_ConvertPtr(argv[0], &argp2,SWIGTYPE_p_GeosGeometry, 0 |  0 );
   if (!SWIG_IsOK(res2)) {
-    SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "difference" "', argument " "2"" of type '" "GeosGeometry *""'"); 
+    SWIG_exception_fail(SWIG_ArgError(res2), Ruby_Format_TypeError( "", "GeosGeometry *","difference", 2, argv[0] )); 
   }
   arg2 = reinterpret_cast< GeosGeometry * >(argp2);
   {
@@ -3631,11 +5789,11 @@
 _wrap_Geometry_sym_difference(int argc, VALUE *argv, VALUE self) {
   GeosGeometry *arg1 = (GeosGeometry *) 0 ;
   GeosGeometry *arg2 = (GeosGeometry *) 0 ;
-  GeosGeometry *result = 0 ;
   void *argp1 = 0 ;
   int res1 = 0 ;
   void *argp2 = 0 ;
   int res2 = 0 ;
+  GeosGeometry *result = 0 ;
   VALUE vresult = Qnil;
   
   if ((argc < 1) || (argc > 1)) {
@@ -3643,12 +5801,12 @@
   }
   res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_GeosGeometry, 0 |  0 );
   if (!SWIG_IsOK(res1)) {
-    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "symDifference" "', argument " "1"" of type '" "GeosGeometry *""'"); 
+    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "GeosGeometry *","symDifference", 1, self )); 
   }
   arg1 = reinterpret_cast< GeosGeometry * >(argp1);
   res2 = SWIG_ConvertPtr(argv[0], &argp2,SWIGTYPE_p_GeosGeometry, 0 |  0 );
   if (!SWIG_IsOK(res2)) {
-    SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "symDifference" "', argument " "2"" of type '" "GeosGeometry *""'"); 
+    SWIG_exception_fail(SWIG_ArgError(res2), Ruby_Format_TypeError( "", "GeosGeometry *","symDifference", 2, argv[0] )); 
   }
   arg2 = reinterpret_cast< GeosGeometry * >(argp2);
   {
@@ -3707,9 +5865,9 @@
 SWIGINTERN VALUE
 _wrap_Geometry_boundary(int argc, VALUE *argv, VALUE self) {
   GeosGeometry *arg1 = (GeosGeometry *) 0 ;
-  GeosGeometry *result = 0 ;
   void *argp1 = 0 ;
   int res1 = 0 ;
+  GeosGeometry *result = 0 ;
   VALUE vresult = Qnil;
   
   if ((argc < 0) || (argc > 0)) {
@@ -3717,7 +5875,7 @@
   }
   res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_GeosGeometry, 0 |  0 );
   if (!SWIG_IsOK(res1)) {
-    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "boundary" "', argument " "1"" of type '" "GeosGeometry *""'"); 
+    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "GeosGeometry *","boundary", 1, self )); 
   }
   arg1 = reinterpret_cast< GeosGeometry * >(argp1);
   {
@@ -3777,11 +5935,11 @@
 _wrap_Geometry_union(int argc, VALUE *argv, VALUE self) {
   GeosGeometry *arg1 = (GeosGeometry *) 0 ;
   GeosGeometry *arg2 = (GeosGeometry *) 0 ;
-  GeosGeometry *result = 0 ;
   void *argp1 = 0 ;
   int res1 = 0 ;
   void *argp2 = 0 ;
   int res2 = 0 ;
+  GeosGeometry *result = 0 ;
   VALUE vresult = Qnil;
   
   if ((argc < 1) || (argc > 1)) {
@@ -3789,12 +5947,12 @@
   }
   res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_GeosGeometry, 0 |  0 );
   if (!SWIG_IsOK(res1)) {
-    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "geomUnion" "', argument " "1"" of type '" "GeosGeometry *""'"); 
+    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "GeosGeometry *","geomUnion", 1, self )); 
   }
   arg1 = reinterpret_cast< GeosGeometry * >(argp1);
   res2 = SWIG_ConvertPtr(argv[0], &argp2,SWIGTYPE_p_GeosGeometry, 0 |  0 );
   if (!SWIG_IsOK(res2)) {
-    SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "geomUnion" "', argument " "2"" of type '" "GeosGeometry *""'"); 
+    SWIG_exception_fail(SWIG_ArgError(res2), Ruby_Format_TypeError( "", "GeosGeometry *","geomUnion", 2, argv[0] )); 
   }
   arg2 = reinterpret_cast< GeosGeometry * >(argp2);
   {
@@ -3853,9 +6011,9 @@
 SWIGINTERN VALUE
 _wrap_Geometry_point_on_surface(int argc, VALUE *argv, VALUE self) {
   GeosGeometry *arg1 = (GeosGeometry *) 0 ;
-  GeosGeometry *result = 0 ;
   void *argp1 = 0 ;
   int res1 = 0 ;
+  GeosGeometry *result = 0 ;
   VALUE vresult = Qnil;
   
   if ((argc < 0) || (argc > 0)) {
@@ -3863,7 +6021,7 @@
   }
   res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_GeosGeometry, 0 |  0 );
   if (!SWIG_IsOK(res1)) {
-    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "pointOnSurface" "', argument " "1"" of type '" "GeosGeometry *""'"); 
+    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "GeosGeometry *","pointOnSurface", 1, self )); 
   }
   arg1 = reinterpret_cast< GeosGeometry * >(argp1);
   {
@@ -3922,9 +6080,9 @@
 SWIGINTERN VALUE
 _wrap_Geometry_centroid(int argc, VALUE *argv, VALUE self) {
   GeosGeometry *arg1 = (GeosGeometry *) 0 ;
-  GeosGeometry *result = 0 ;
   void *argp1 = 0 ;
   int res1 = 0 ;
+  GeosGeometry *result = 0 ;
   VALUE vresult = Qnil;
   
   if ((argc < 0) || (argc > 0)) {
@@ -3932,7 +6090,7 @@
   }
   res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_GeosGeometry, 0 |  0 );
   if (!SWIG_IsOK(res1)) {
-    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "getCentroid" "', argument " "1"" of type '" "GeosGeometry *""'"); 
+    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "GeosGeometry *","getCentroid", 1, self )); 
   }
   arg1 = reinterpret_cast< GeosGeometry * >(argp1);
   {
@@ -3991,9 +6149,9 @@
 SWIGINTERN VALUE
 _wrap_Geometry_envelope(int argc, VALUE *argv, VALUE self) {
   GeosGeometry *arg1 = (GeosGeometry *) 0 ;
-  GeosGeometry *result = 0 ;
   void *argp1 = 0 ;
   int res1 = 0 ;
+  GeosGeometry *result = 0 ;
   VALUE vresult = Qnil;
   
   if ((argc < 0) || (argc > 0)) {
@@ -4001,7 +6159,7 @@
   }
   res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_GeosGeometry, 0 |  0 );
   if (!SWIG_IsOK(res1)) {
-    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "getEnvelope" "', argument " "1"" of type '" "GeosGeometry *""'"); 
+    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "GeosGeometry *","getEnvelope", 1, self )); 
   }
   arg1 = reinterpret_cast< GeosGeometry * >(argp1);
   {
@@ -4061,11 +6219,11 @@
 _wrap_Geometry_relate(int argc, VALUE *argv, VALUE self) {
   GeosGeometry *arg1 = (GeosGeometry *) 0 ;
   GeosGeometry *arg2 = (GeosGeometry *) 0 ;
-  char *result = 0 ;
   void *argp1 = 0 ;
   int res1 = 0 ;
   void *argp2 = 0 ;
   int res2 = 0 ;
+  char *result = 0 ;
   VALUE vresult = Qnil;
   
   if ((argc < 1) || (argc > 1)) {
@@ -4073,12 +6231,12 @@
   }
   res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_GeosGeometry, 0 |  0 );
   if (!SWIG_IsOK(res1)) {
-    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "relate" "', argument " "1"" of type '" "GeosGeometry *""'"); 
+    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "GeosGeometry *","relate", 1, self )); 
   }
   arg1 = reinterpret_cast< GeosGeometry * >(argp1);
   res2 = SWIG_ConvertPtr(argv[0], &argp2,SWIGTYPE_p_GeosGeometry, 0 |  0 );
   if (!SWIG_IsOK(res2)) {
-    SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "relate" "', argument " "2"" of type '" "GeosGeometry *""'"); 
+    SWIG_exception_fail(SWIG_ArgError(res2), Ruby_Format_TypeError( "", "GeosGeometry *","relate", 2, argv[0] )); 
   }
   arg2 = reinterpret_cast< GeosGeometry * >(argp2);
   {
@@ -4102,9 +6260,9 @@
 SWIGINTERN VALUE
 _wrap_Geometry_line_merge(int argc, VALUE *argv, VALUE self) {
   GeosGeometry *arg1 = (GeosGeometry *) 0 ;
-  GeosGeometry *result = 0 ;
   void *argp1 = 0 ;
   int res1 = 0 ;
+  GeosGeometry *result = 0 ;
   VALUE vresult = Qnil;
   
   if ((argc < 0) || (argc > 0)) {
@@ -4112,7 +6270,7 @@
   }
   res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_GeosGeometry, 0 |  0 );
   if (!SWIG_IsOK(res1)) {
-    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "lineMerge" "', argument " "1"" of type '" "GeosGeometry *""'"); 
+    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "GeosGeometry *","lineMerge", 1, self )); 
   }
   arg1 = reinterpret_cast< GeosGeometry * >(argp1);
   {
@@ -4172,11 +6330,11 @@
 _wrap_Geometry_simplify(int argc, VALUE *argv, VALUE self) {
   GeosGeometry *arg1 = (GeosGeometry *) 0 ;
   double arg2 ;
-  GeosGeometry *result = 0 ;
   void *argp1 = 0 ;
   int res1 = 0 ;
   double val2 ;
   int ecode2 = 0 ;
+  GeosGeometry *result = 0 ;
   VALUE vresult = Qnil;
   
   if ((argc < 1) || (argc > 1)) {
@@ -4184,12 +6342,12 @@
   }
   res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_GeosGeometry, 0 |  0 );
   if (!SWIG_IsOK(res1)) {
-    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "simplify" "', argument " "1"" of type '" "GeosGeometry *""'"); 
+    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "GeosGeometry *","simplify", 1, self )); 
   }
   arg1 = reinterpret_cast< GeosGeometry * >(argp1);
   ecode2 = SWIG_AsVal_double(argv[0], &val2);
   if (!SWIG_IsOK(ecode2)) {
-    SWIG_exception_fail(SWIG_ArgError(ecode2), "in method '" "simplify" "', argument " "2"" of type '" "double""'");
+    SWIG_exception_fail(SWIG_ArgError(ecode2), Ruby_Format_TypeError( "", "double","simplify", 2, argv[0] ));
   } 
   arg2 = static_cast< double >(val2);
   {
@@ -4249,11 +6407,11 @@
 _wrap_Geometry_topology_preserve_simplify(int argc, VALUE *argv, VALUE self) {
   GeosGeometry *arg1 = (GeosGeometry *) 0 ;
   double arg2 ;
-  GeosGeometry *result = 0 ;
   void *argp1 = 0 ;
   int res1 = 0 ;
   double val2 ;
   int ecode2 = 0 ;
+  GeosGeometry *result = 0 ;
   VALUE vresult = Qnil;
   
   if ((argc < 1) || (argc > 1)) {
@@ -4261,12 +6419,12 @@
   }
   res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_GeosGeometry, 0 |  0 );
   if (!SWIG_IsOK(res1)) {
-    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "topologyPreserveSimplify" "', argument " "1"" of type '" "GeosGeometry *""'"); 
+    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "GeosGeometry *","topologyPreserveSimplify", 1, self )); 
   }
   arg1 = reinterpret_cast< GeosGeometry * >(argp1);
   ecode2 = SWIG_AsVal_double(argv[0], &val2);
   if (!SWIG_IsOK(ecode2)) {
-    SWIG_exception_fail(SWIG_ArgError(ecode2), "in method '" "topologyPreserveSimplify" "', argument " "2"" of type '" "double""'");
+    SWIG_exception_fail(SWIG_ArgError(ecode2), Ruby_Format_TypeError( "", "double","topologyPreserveSimplify", 2, argv[0] ));
   } 
   arg2 = static_cast< double >(val2);
   {
@@ -4327,7 +6485,6 @@
   GeosGeometry *arg1 = (GeosGeometry *) 0 ;
   GeosGeometry *arg2 = (GeosGeometry *) 0 ;
   char *arg3 = (char *) 0 ;
-  bool result;
   void *argp1 = 0 ;
   int res1 = 0 ;
   void *argp2 = 0 ;
@@ -4335,6 +6492,7 @@
   int res3 ;
   char *buf3 = 0 ;
   int alloc3 = 0 ;
+  bool result;
   VALUE vresult = Qnil;
   
   if ((argc < 2) || (argc > 2)) {
@@ -4342,17 +6500,17 @@
   }
   res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_GeosGeometry, 0 |  0 );
   if (!SWIG_IsOK(res1)) {
-    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "relatePattern" "', argument " "1"" of type '" "GeosGeometry *""'"); 
+    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "GeosGeometry *","relatePattern", 1, self )); 
   }
   arg1 = reinterpret_cast< GeosGeometry * >(argp1);
   res2 = SWIG_ConvertPtr(argv[0], &argp2,SWIGTYPE_p_GeosGeometry, 0 |  0 );
   if (!SWIG_IsOK(res2)) {
-    SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "relatePattern" "', argument " "2"" of type '" "GeosGeometry const *""'"); 
+    SWIG_exception_fail(SWIG_ArgError(res2), Ruby_Format_TypeError( "", "GeosGeometry const *","relatePattern", 2, argv[0] )); 
   }
   arg2 = reinterpret_cast< GeosGeometry * >(argp2);
   res3 = SWIG_AsCharPtrAndSize(argv[1], &buf3, NULL, &alloc3);
   if (!SWIG_IsOK(res3)) {
-    SWIG_exception_fail(SWIG_ArgError(res3), "in method '" "relatePattern" "', argument " "3"" of type '" "char const *""'");
+    SWIG_exception_fail(SWIG_ArgError(res3), Ruby_Format_TypeError( "", "char const *","relatePattern", 3, argv[1] ));
   }
   arg3 = reinterpret_cast< char * >(buf3);
   {
@@ -4378,11 +6536,11 @@
 _wrap_Geometry_disjointq___(int argc, VALUE *argv, VALUE self) {
   GeosGeometry *arg1 = (GeosGeometry *) 0 ;
   GeosGeometry *arg2 = (GeosGeometry *) 0 ;
-  bool result;
   void *argp1 = 0 ;
   int res1 = 0 ;
   void *argp2 = 0 ;
   int res2 = 0 ;
+  bool result;
   VALUE vresult = Qnil;
   
   if ((argc < 1) || (argc > 1)) {
@@ -4390,12 +6548,12 @@
   }
   res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_GeosGeometry, 0 |  0 );
   if (!SWIG_IsOK(res1)) {
-    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "disjoint" "', argument " "1"" of type '" "GeosGeometry *""'"); 
+    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "GeosGeometry *","disjoint", 1, self )); 
   }
   arg1 = reinterpret_cast< GeosGeometry * >(argp1);
   res2 = SWIG_ConvertPtr(argv[0], &argp2,SWIGTYPE_p_GeosGeometry, 0 |  0 );
   if (!SWIG_IsOK(res2)) {
-    SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "disjoint" "', argument " "2"" of type '" "GeosGeometry const *""'"); 
+    SWIG_exception_fail(SWIG_ArgError(res2), Ruby_Format_TypeError( "", "GeosGeometry const *","disjoint", 2, argv[0] )); 
   }
   arg2 = reinterpret_cast< GeosGeometry * >(argp2);
   {
@@ -4419,11 +6577,11 @@
 _wrap_Geometry_touchesq___(int argc, VALUE *argv, VALUE self) {
   GeosGeometry *arg1 = (GeosGeometry *) 0 ;
   GeosGeometry *arg2 = (GeosGeometry *) 0 ;
-  bool result;
   void *argp1 = 0 ;
   int res1 = 0 ;
   void *argp2 = 0 ;
   int res2 = 0 ;
+  bool result;
   VALUE vresult = Qnil;
   
   if ((argc < 1) || (argc > 1)) {
@@ -4431,12 +6589,12 @@
   }
   res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_GeosGeometry, 0 |  0 );
   if (!SWIG_IsOK(res1)) {
-    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "touches" "', argument " "1"" of type '" "GeosGeometry *""'"); 
+    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "GeosGeometry *","touches", 1, self )); 
   }
   arg1 = reinterpret_cast< GeosGeometry * >(argp1);
   res2 = SWIG_ConvertPtr(argv[0], &argp2,SWIGTYPE_p_GeosGeometry, 0 |  0 );
   if (!SWIG_IsOK(res2)) {
-    SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "touches" "', argument " "2"" of type '" "GeosGeometry const *""'"); 
+    SWIG_exception_fail(SWIG_ArgError(res2), Ruby_Format_TypeError( "", "GeosGeometry const *","touches", 2, argv[0] )); 
   }
   arg2 = reinterpret_cast< GeosGeometry * >(argp2);
   {
@@ -4460,11 +6618,11 @@
 _wrap_Geometry_intersectsq___(int argc, VALUE *argv, VALUE self) {
   GeosGeometry *arg1 = (GeosGeometry *) 0 ;
   GeosGeometry *arg2 = (GeosGeometry *) 0 ;
-  bool result;
   void *argp1 = 0 ;
   int res1 = 0 ;
   void *argp2 = 0 ;
   int res2 = 0 ;
+  bool result;
   VALUE vresult = Qnil;
   
   if ((argc < 1) || (argc > 1)) {
@@ -4472,12 +6630,12 @@
   }
   res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_GeosGeometry, 0 |  0 );
   if (!SWIG_IsOK(res1)) {
-    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "intersects" "', argument " "1"" of type '" "GeosGeometry *""'"); 
+    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "GeosGeometry *","intersects", 1, self )); 
   }
   arg1 = reinterpret_cast< GeosGeometry * >(argp1);
   res2 = SWIG_ConvertPtr(argv[0], &argp2,SWIGTYPE_p_GeosGeometry, 0 |  0 );
   if (!SWIG_IsOK(res2)) {
-    SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "intersects" "', argument " "2"" of type '" "GeosGeometry const *""'"); 
+    SWIG_exception_fail(SWIG_ArgError(res2), Ruby_Format_TypeError( "", "GeosGeometry const *","intersects", 2, argv[0] )); 
   }
   arg2 = reinterpret_cast< GeosGeometry * >(argp2);
   {
@@ -4501,11 +6659,11 @@
 _wrap_Geometry_crossesq___(int argc, VALUE *argv, VALUE self) {
   GeosGeometry *arg1 = (GeosGeometry *) 0 ;
   GeosGeometry *arg2 = (GeosGeometry *) 0 ;
-  bool result;
   void *argp1 = 0 ;
   int res1 = 0 ;
   void *argp2 = 0 ;
   int res2 = 0 ;
+  bool result;
   VALUE vresult = Qnil;
   
   if ((argc < 1) || (argc > 1)) {
@@ -4513,12 +6671,12 @@
   }
   res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_GeosGeometry, 0 |  0 );
   if (!SWIG_IsOK(res1)) {
-    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "crosses" "', argument " "1"" of type '" "GeosGeometry *""'"); 
+    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "GeosGeometry *","crosses", 1, self )); 
   }
   arg1 = reinterpret_cast< GeosGeometry * >(argp1);
   res2 = SWIG_ConvertPtr(argv[0], &argp2,SWIGTYPE_p_GeosGeometry, 0 |  0 );
   if (!SWIG_IsOK(res2)) {
-    SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "crosses" "', argument " "2"" of type '" "GeosGeometry const *""'"); 
+    SWIG_exception_fail(SWIG_ArgError(res2), Ruby_Format_TypeError( "", "GeosGeometry const *","crosses", 2, argv[0] )); 
   }
   arg2 = reinterpret_cast< GeosGeometry * >(argp2);
   {
@@ -4542,11 +6700,11 @@
 _wrap_Geometry_withinq___(int argc, VALUE *argv, VALUE self) {
   GeosGeometry *arg1 = (GeosGeometry *) 0 ;
   GeosGeometry *arg2 = (GeosGeometry *) 0 ;
-  bool result;
   void *argp1 = 0 ;
   int res1 = 0 ;
   void *argp2 = 0 ;
   int res2 = 0 ;
+  bool result;
   VALUE vresult = Qnil;
   
   if ((argc < 1) || (argc > 1)) {
@@ -4554,12 +6712,12 @@
   }
   res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_GeosGeometry, 0 |  0 );
   if (!SWIG_IsOK(res1)) {
-    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "within" "', argument " "1"" of type '" "GeosGeometry *""'"); 
+    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "GeosGeometry *","within", 1, self )); 
   }
   arg1 = reinterpret_cast< GeosGeometry * >(argp1);
   res2 = SWIG_ConvertPtr(argv[0], &argp2,SWIGTYPE_p_GeosGeometry, 0 |  0 );
   if (!SWIG_IsOK(res2)) {
-    SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "within" "', argument " "2"" of type '" "GeosGeometry const *""'"); 
+    SWIG_exception_fail(SWIG_ArgError(res2), Ruby_Format_TypeError( "", "GeosGeometry const *","within", 2, argv[0] )); 
   }
   arg2 = reinterpret_cast< GeosGeometry * >(argp2);
   {
@@ -4583,11 +6741,11 @@
 _wrap_Geometry_containsq___(int argc, VALUE *argv, VALUE self) {
   GeosGeometry *arg1 = (GeosGeometry *) 0 ;
   GeosGeometry *arg2 = (GeosGeometry *) 0 ;
-  bool result;
   void *argp1 = 0 ;
   int res1 = 0 ;
   void *argp2 = 0 ;
   int res2 = 0 ;
+  bool result;
   VALUE vresult = Qnil;
   
   if ((argc < 1) || (argc > 1)) {
@@ -4595,12 +6753,12 @@
   }
   res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_GeosGeometry, 0 |  0 );
   if (!SWIG_IsOK(res1)) {
-    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "contains" "', argument " "1"" of type '" "GeosGeometry *""'"); 
+    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "GeosGeometry *","contains", 1, self )); 
   }
   arg1 = reinterpret_cast< GeosGeometry * >(argp1);
   res2 = SWIG_ConvertPtr(argv[0], &argp2,SWIGTYPE_p_GeosGeometry, 0 |  0 );
   if (!SWIG_IsOK(res2)) {
-    SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "contains" "', argument " "2"" of type '" "GeosGeometry const *""'"); 
+    SWIG_exception_fail(SWIG_ArgError(res2), Ruby_Format_TypeError( "", "GeosGeometry const *","contains", 2, argv[0] )); 
   }
   arg2 = reinterpret_cast< GeosGeometry * >(argp2);
   {
@@ -4624,11 +6782,11 @@
 _wrap_Geometry_overlapsq___(int argc, VALUE *argv, VALUE self) {
   GeosGeometry *arg1 = (GeosGeometry *) 0 ;
   GeosGeometry *arg2 = (GeosGeometry *) 0 ;
-  bool result;
   void *argp1 = 0 ;
   int res1 = 0 ;
   void *argp2 = 0 ;
   int res2 = 0 ;
+  bool result;
   VALUE vresult = Qnil;
   
   if ((argc < 1) || (argc > 1)) {
@@ -4636,12 +6794,12 @@
   }
   res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_GeosGeometry, 0 |  0 );
   if (!SWIG_IsOK(res1)) {
-    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "overlaps" "', argument " "1"" of type '" "GeosGeometry *""'"); 
+    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "GeosGeometry *","overlaps", 1, self )); 
   }
   arg1 = reinterpret_cast< GeosGeometry * >(argp1);
   res2 = SWIG_ConvertPtr(argv[0], &argp2,SWIGTYPE_p_GeosGeometry, 0 |  0 );
   if (!SWIG_IsOK(res2)) {
-    SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "overlaps" "', argument " "2"" of type '" "GeosGeometry const *""'"); 
+    SWIG_exception_fail(SWIG_ArgError(res2), Ruby_Format_TypeError( "", "GeosGeometry const *","overlaps", 2, argv[0] )); 
   }
   arg2 = reinterpret_cast< GeosGeometry * >(argp2);
   {
@@ -4665,11 +6823,11 @@
 _wrap_Geometry_eqlq___(int argc, VALUE *argv, VALUE self) {
   GeosGeometry *arg1 = (GeosGeometry *) 0 ;
   GeosGeometry *arg2 = (GeosGeometry *) 0 ;
-  bool result;
   void *argp1 = 0 ;
   int res1 = 0 ;
   void *argp2 = 0 ;
   int res2 = 0 ;
+  bool result;
   VALUE vresult = Qnil;
   
   if ((argc < 1) || (argc > 1)) {
@@ -4677,12 +6835,12 @@
   }
   res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_GeosGeometry, 0 |  0 );
   if (!SWIG_IsOK(res1)) {
-    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "equals" "', argument " "1"" of type '" "GeosGeometry *""'"); 
+    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "GeosGeometry *","equals", 1, self )); 
   }
   arg1 = reinterpret_cast< GeosGeometry * >(argp1);
   res2 = SWIG_ConvertPtr(argv[0], &argp2,SWIGTYPE_p_GeosGeometry, 0 |  0 );
   if (!SWIG_IsOK(res2)) {
-    SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "equals" "', argument " "2"" of type '" "GeosGeometry const *""'"); 
+    SWIG_exception_fail(SWIG_ArgError(res2), Ruby_Format_TypeError( "", "GeosGeometry const *","equals", 2, argv[0] )); 
   }
   arg2 = reinterpret_cast< GeosGeometry * >(argp2);
   {
@@ -4707,13 +6865,13 @@
   GeosGeometry *arg1 = (GeosGeometry *) 0 ;
   GeosGeometry *arg2 = (GeosGeometry *) 0 ;
   double arg3 ;
-  bool result;
   void *argp1 = 0 ;
   int res1 = 0 ;
   void *argp2 = 0 ;
   int res2 = 0 ;
   double val3 ;
   int ecode3 = 0 ;
+  bool result;
   VALUE vresult = Qnil;
   
   if ((argc < 2) || (argc > 2)) {
@@ -4721,17 +6879,17 @@
   }
   res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_GeosGeometry, 0 |  0 );
   if (!SWIG_IsOK(res1)) {
-    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "equalsExact" "', argument " "1"" of type '" "GeosGeometry *""'"); 
+    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "GeosGeometry *","equalsExact", 1, self )); 
   }
   arg1 = reinterpret_cast< GeosGeometry * >(argp1);
   res2 = SWIG_ConvertPtr(argv[0], &argp2,SWIGTYPE_p_GeosGeometry, 0 |  0 );
   if (!SWIG_IsOK(res2)) {
-    SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "equalsExact" "', argument " "2"" of type '" "GeosGeometry const *""'"); 
+    SWIG_exception_fail(SWIG_ArgError(res2), Ruby_Format_TypeError( "", "GeosGeometry const *","equalsExact", 2, argv[0] )); 
   }
   arg2 = reinterpret_cast< GeosGeometry * >(argp2);
   ecode3 = SWIG_AsVal_double(argv[1], &val3);
   if (!SWIG_IsOK(ecode3)) {
-    SWIG_exception_fail(SWIG_ArgError(ecode3), "in method '" "equalsExact" "', argument " "3"" of type '" "double""'");
+    SWIG_exception_fail(SWIG_ArgError(ecode3), Ruby_Format_TypeError( "", "double","equalsExact", 3, argv[1] ));
   } 
   arg3 = static_cast< double >(val3);
   {
@@ -4754,9 +6912,9 @@
 SWIGINTERN VALUE
 _wrap_Geometry_emptyq___(int argc, VALUE *argv, VALUE self) {
   GeosGeometry *arg1 = (GeosGeometry *) 0 ;
-  bool result;
   void *argp1 = 0 ;
   int res1 = 0 ;
+  bool result;
   VALUE vresult = Qnil;
   
   if ((argc < 0) || (argc > 0)) {
@@ -4764,7 +6922,7 @@
   }
   res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_GeosGeometry, 0 |  0 );
   if (!SWIG_IsOK(res1)) {
-    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "isEmpty" "', argument " "1"" of type '" "GeosGeometry *""'"); 
+    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "GeosGeometry *","isEmpty", 1, self )); 
   }
   arg1 = reinterpret_cast< GeosGeometry * >(argp1);
   {
@@ -4787,9 +6945,9 @@
 SWIGINTERN VALUE
 _wrap_Geometry_validq___(int argc, VALUE *argv, VALUE self) {
   GeosGeometry *arg1 = (GeosGeometry *) 0 ;
-  bool result;
   void *argp1 = 0 ;
   int res1 = 0 ;
+  bool result;
   VALUE vresult = Qnil;
   
   if ((argc < 0) || (argc > 0)) {
@@ -4797,7 +6955,7 @@
   }
   res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_GeosGeometry, 0 |  0 );
   if (!SWIG_IsOK(res1)) {
-    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "isValid" "', argument " "1"" of type '" "GeosGeometry *""'"); 
+    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "GeosGeometry *","isValid", 1, self )); 
   }
   arg1 = reinterpret_cast< GeosGeometry * >(argp1);
   {
@@ -4820,9 +6978,9 @@
 SWIGINTERN VALUE
 _wrap_Geometry_simpleq___(int argc, VALUE *argv, VALUE self) {
   GeosGeometry *arg1 = (GeosGeometry *) 0 ;
-  bool result;
   void *argp1 = 0 ;
   int res1 = 0 ;
+  bool result;
   VALUE vresult = Qnil;
   
   if ((argc < 0) || (argc > 0)) {
@@ -4830,7 +6988,7 @@
   }
   res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_GeosGeometry, 0 |  0 );
   if (!SWIG_IsOK(res1)) {
-    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "isSimple" "', argument " "1"" of type '" "GeosGeometry *""'"); 
+    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "GeosGeometry *","isSimple", 1, self )); 
   }
   arg1 = reinterpret_cast< GeosGeometry * >(argp1);
   {
@@ -4853,9 +7011,9 @@
 SWIGINTERN VALUE
 _wrap_Geometry_ringq___(int argc, VALUE *argv, VALUE self) {
   GeosGeometry *arg1 = (GeosGeometry *) 0 ;
-  bool result;
   void *argp1 = 0 ;
   int res1 = 0 ;
+  bool result;
   VALUE vresult = Qnil;
   
   if ((argc < 0) || (argc > 0)) {
@@ -4863,7 +7021,7 @@
   }
   res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_GeosGeometry, 0 |  0 );
   if (!SWIG_IsOK(res1)) {
-    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "isRing" "', argument " "1"" of type '" "GeosGeometry *""'"); 
+    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "GeosGeometry *","isRing", 1, self )); 
   }
   arg1 = reinterpret_cast< GeosGeometry * >(argp1);
   {
@@ -4886,9 +7044,9 @@
 SWIGINTERN VALUE
 _wrap_Geometry_has_zq___(int argc, VALUE *argv, VALUE self) {
   GeosGeometry *arg1 = (GeosGeometry *) 0 ;
-  bool result;
   void *argp1 = 0 ;
   int res1 = 0 ;
+  bool result;
   VALUE vresult = Qnil;
   
   if ((argc < 0) || (argc > 0)) {
@@ -4896,7 +7054,7 @@
   }
   res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_GeosGeometry, 0 |  0 );
   if (!SWIG_IsOK(res1)) {
-    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "hasZ" "', argument " "1"" of type '" "GeosGeometry *""'"); 
+    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "GeosGeometry *","hasZ", 1, self )); 
   }
   arg1 = reinterpret_cast< GeosGeometry * >(argp1);
   {
@@ -4919,9 +7077,9 @@
 SWIGINTERN VALUE
 _wrap_Geometry_area(int argc, VALUE *argv, VALUE self) {
   GeosGeometry *arg1 = (GeosGeometry *) 0 ;
-  double result;
   void *argp1 = 0 ;
   int res1 = 0 ;
+  double result;
   VALUE vresult = Qnil;
   
   if ((argc < 0) || (argc > 0)) {
@@ -4929,7 +7087,7 @@
   }
   res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_GeosGeometry, 0 |  0 );
   if (!SWIG_IsOK(res1)) {
-    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "area" "', argument " "1"" of type '" "GeosGeometry *""'"); 
+    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "GeosGeometry *","area", 1, self )); 
   }
   arg1 = reinterpret_cast< GeosGeometry * >(argp1);
   {
@@ -4949,12 +7107,21 @@
 }
 
 
+
+/*
+  Document-method: Geos::Geometry.length
+
+  call-seq:
+    length -> double
+
+Size or Length of the Geometry.
+*/
 SWIGINTERN VALUE
 _wrap_Geometry_length(int argc, VALUE *argv, VALUE self) {
   GeosGeometry *arg1 = (GeosGeometry *) 0 ;
-  double result;
   void *argp1 = 0 ;
   int res1 = 0 ;
+  double result;
   VALUE vresult = Qnil;
   
   if ((argc < 0) || (argc > 0)) {
@@ -4962,7 +7129,7 @@
   }
   res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_GeosGeometry, 0 |  0 );
   if (!SWIG_IsOK(res1)) {
-    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "length" "', argument " "1"" of type '" "GeosGeometry *""'"); 
+    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "GeosGeometry *","length", 1, self )); 
   }
   arg1 = reinterpret_cast< GeosGeometry * >(argp1);
   {
@@ -4986,11 +7153,11 @@
 _wrap_Geometry_distance(int argc, VALUE *argv, VALUE self) {
   GeosGeometry *arg1 = (GeosGeometry *) 0 ;
   GeosGeometry *arg2 = (GeosGeometry *) 0 ;
-  double result;
   void *argp1 = 0 ;
   int res1 = 0 ;
   void *argp2 = 0 ;
   int res2 = 0 ;
+  double result;
   VALUE vresult = Qnil;
   
   if ((argc < 1) || (argc > 1)) {
@@ -4998,12 +7165,12 @@
   }
   res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_GeosGeometry, 0 |  0 );
   if (!SWIG_IsOK(res1)) {
-    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "distance" "', argument " "1"" of type '" "GeosGeometry *""'"); 
+    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "GeosGeometry *","distance", 1, self )); 
   }
   arg1 = reinterpret_cast< GeosGeometry * >(argp1);
   res2 = SWIG_ConvertPtr(argv[0], &argp2,SWIGTYPE_p_GeosGeometry, 0 |  0 );
   if (!SWIG_IsOK(res2)) {
-    SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "distance" "', argument " "2"" of type '" "GeosGeometry const *""'"); 
+    SWIG_exception_fail(SWIG_ArgError(res2), Ruby_Format_TypeError( "", "GeosGeometry const *","distance", 2, argv[0] )); 
   }
   arg2 = reinterpret_cast< GeosGeometry * >(argp2);
   {
@@ -5023,7 +7190,7 @@
 }
 
 
-swig_class cPoint;
+swig_class SwigClassPoint;
 
 SWIGINTERN void delete_GeosPoint(GeosPoint *self){
         GEOSGeom geom = (GEOSGeom) self;
@@ -5037,9 +7204,9 @@
 SWIGINTERN VALUE
 _wrap_Point_coord_seq(int argc, VALUE *argv, VALUE self) {
   GeosPoint *arg1 = (GeosPoint *) 0 ;
-  GeosCoordinateSequence *result = 0 ;
   void *argp1 = 0 ;
   int res1 = 0 ;
+  GeosCoordinateSequence *result = 0 ;
   VALUE vresult = Qnil;
   
   if ((argc < 0) || (argc > 0)) {
@@ -5047,7 +7214,7 @@
   }
   res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_GeosPoint, 0 |  0 );
   if (!SWIG_IsOK(res1)) {
-    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "getCoordSeq" "', argument " "1"" of type '" "GeosPoint *""'"); 
+    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "GeosPoint *","getCoordSeq", 1, self )); 
   }
   arg1 = reinterpret_cast< GeosPoint * >(argp1);
   {
@@ -5067,7 +7234,7 @@
 }
 
 
-swig_class cLineString;
+swig_class SwigClassLineString;
 
 SWIGINTERN void delete_GeosLineString(GeosLineString *self){
         GEOSGeom geom = (GEOSGeom) self;
@@ -5081,9 +7248,9 @@
 SWIGINTERN VALUE
 _wrap_LineString_coord_seq(int argc, VALUE *argv, VALUE self) {
   GeosLineString *arg1 = (GeosLineString *) 0 ;
-  GeosCoordinateSequence *result = 0 ;
   void *argp1 = 0 ;
   int res1 = 0 ;
+  GeosCoordinateSequence *result = 0 ;
   VALUE vresult = Qnil;
   
   if ((argc < 0) || (argc > 0)) {
@@ -5091,7 +7258,7 @@
   }
   res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_GeosLineString, 0 |  0 );
   if (!SWIG_IsOK(res1)) {
-    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "getCoordSeq" "', argument " "1"" of type '" "GeosLineString *""'"); 
+    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "GeosLineString *","getCoordSeq", 1, self )); 
   }
   arg1 = reinterpret_cast< GeosLineString * >(argp1);
   {
@@ -5111,7 +7278,7 @@
 }
 
 
-swig_class cLinearRing;
+swig_class SwigClassLinearRing;
 
 SWIGINTERN void delete_GeosLinearRing(GeosLinearRing *self){
         GEOSGeom geom = (GEOSGeom) self;
@@ -5125,9 +7292,9 @@
 SWIGINTERN VALUE
 _wrap_LinearRing_coord_seq(int argc, VALUE *argv, VALUE self) {
   GeosLinearRing *arg1 = (GeosLinearRing *) 0 ;
-  GeosCoordinateSequence *result = 0 ;
   void *argp1 = 0 ;
   int res1 = 0 ;
+  GeosCoordinateSequence *result = 0 ;
   VALUE vresult = Qnil;
   
   if ((argc < 0) || (argc > 0)) {
@@ -5135,7 +7302,7 @@
   }
   res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_GeosLinearRing, 0 |  0 );
   if (!SWIG_IsOK(res1)) {
-    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "getCoordSeq" "', argument " "1"" of type '" "GeosLinearRing *""'"); 
+    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "GeosLinearRing *","getCoordSeq", 1, self )); 
   }
   arg1 = reinterpret_cast< GeosLinearRing * >(argp1);
   {
@@ -5155,7 +7322,7 @@
 }
 
 
-swig_class cPolygon;
+swig_class SwigClassPolygon;
 
 SWIGINTERN void delete_GeosPolygon(GeosPolygon *self){
         GEOSGeom geom = (GEOSGeom) self;
@@ -5169,9 +7336,9 @@
 SWIGINTERN VALUE
 _wrap_Polygon_exterior_ring(int argc, VALUE *argv, VALUE self) {
   GeosPolygon *arg1 = (GeosPolygon *) 0 ;
-  GeosGeometry *result = 0 ;
   void *argp1 = 0 ;
   int res1 = 0 ;
+  GeosGeometry *result = 0 ;
   VALUE vresult = Qnil;
   
   if ((argc < 0) || (argc > 0)) {
@@ -5179,7 +7346,7 @@
   }
   res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_GeosPolygon, 0 |  0 );
   if (!SWIG_IsOK(res1)) {
-    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "getExteriorRing" "', argument " "1"" of type '" "GeosPolygon *""'"); 
+    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "GeosPolygon *","getExteriorRing", 1, self )); 
   }
   arg1 = reinterpret_cast< GeosPolygon * >(argp1);
   {
@@ -5238,9 +7405,9 @@
 SWIGINTERN VALUE
 _wrap_Polygon_num_interior_rings(int argc, VALUE *argv, VALUE self) {
   GeosPolygon *arg1 = (GeosPolygon *) 0 ;
-  size_t result;
   void *argp1 = 0 ;
   int res1 = 0 ;
+  size_t result;
   VALUE vresult = Qnil;
   
   if ((argc < 0) || (argc > 0)) {
@@ -5248,7 +7415,7 @@
   }
   res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_GeosPolygon, 0 |  0 );
   if (!SWIG_IsOK(res1)) {
-    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "getNumInteriorRings" "', argument " "1"" of type '" "GeosPolygon *""'"); 
+    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "GeosPolygon *","getNumInteriorRings", 1, self )); 
   }
   arg1 = reinterpret_cast< GeosPolygon * >(argp1);
   {
@@ -5272,11 +7439,11 @@
 _wrap_Polygon_interior_ring_n(int argc, VALUE *argv, VALUE self) {
   GeosPolygon *arg1 = (GeosPolygon *) 0 ;
   size_t arg2 ;
-  GeosGeometry *result = 0 ;
   void *argp1 = 0 ;
   int res1 = 0 ;
   size_t val2 ;
   int ecode2 = 0 ;
+  GeosGeometry *result = 0 ;
   VALUE vresult = Qnil;
   
   if ((argc < 1) || (argc > 1)) {
@@ -5284,12 +7451,12 @@
   }
   res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_GeosPolygon, 0 |  0 );
   if (!SWIG_IsOK(res1)) {
-    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "getInteriorRingN" "', argument " "1"" of type '" "GeosPolygon *""'"); 
+    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "GeosPolygon *","getInteriorRingN", 1, self )); 
   }
   arg1 = reinterpret_cast< GeosPolygon * >(argp1);
   ecode2 = SWIG_AsVal_size_t(argv[0], &val2);
   if (!SWIG_IsOK(ecode2)) {
-    SWIG_exception_fail(SWIG_ArgError(ecode2), "in method '" "getInteriorRingN" "', argument " "2"" of type '" "size_t""'");
+    SWIG_exception_fail(SWIG_ArgError(ecode2), Ruby_Format_TypeError( "", "size_t","getInteriorRingN", 2, argv[0] ));
   } 
   arg2 = static_cast< size_t >(val2);
   {
@@ -5345,7 +7512,7 @@
 }
 
 
-swig_class cGeometryCollection;
+swig_class SwigClassGeometryCollection;
 
 SWIGINTERN void delete_GeosGeometryCollection(GeosGeometryCollection *self){
         GEOSGeom geom = (GEOSGeom) self;
@@ -5360,11 +7527,11 @@
 _wrap_GeometryCollection_get_geometry_n(int argc, VALUE *argv, VALUE self) {
   GeosGeometryCollection *arg1 = (GeosGeometryCollection *) 0 ;
   size_t arg2 ;
-  GeosGeometry *result = 0 ;
   void *argp1 = 0 ;
   int res1 = 0 ;
   size_t val2 ;
   int ecode2 = 0 ;
+  GeosGeometry *result = 0 ;
   VALUE vresult = Qnil;
   
   if ((argc < 1) || (argc > 1)) {
@@ -5372,12 +7539,12 @@
   }
   res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_GeosGeometryCollection, 0 |  0 );
   if (!SWIG_IsOK(res1)) {
-    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "getGeometryN" "', argument " "1"" of type '" "GeosGeometryCollection *""'"); 
+    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "GeosGeometryCollection *","getGeometryN", 1, self )); 
   }
   arg1 = reinterpret_cast< GeosGeometryCollection * >(argp1);
   ecode2 = SWIG_AsVal_size_t(argv[0], &val2);
   if (!SWIG_IsOK(ecode2)) {
-    SWIG_exception_fail(SWIG_ArgError(ecode2), "in method '" "getGeometryN" "', argument " "2"" of type '" "size_t""'");
+    SWIG_exception_fail(SWIG_ArgError(ecode2), Ruby_Format_TypeError( "", "size_t","getGeometryN", 2, argv[0] ));
   } 
   arg2 = static_cast< size_t >(val2);
   {
@@ -5433,7 +7600,7 @@
 }
 
 
-swig_class cMultiPoint;
+swig_class SwigClassMultiPoint;
 
 SWIGINTERN void delete_GeosMultiPoint(GeosMultiPoint *self){
         GEOSGeom geom = (GEOSGeom) self;
@@ -5444,7 +7611,7 @@
     delete_GeosMultiPoint(arg1);
 }
 
-swig_class cMultiLineString;
+swig_class SwigClassMultiLineString;
 
 SWIGINTERN void delete_GeosMultiLineString(GeosMultiLineString *self){
         GEOSGeom geom = (GEOSGeom) self;
@@ -5455,7 +7622,7 @@
     delete_GeosMultiLineString(arg1);
 }
 
-swig_class cMultiLinearRing;
+swig_class SwigClassMultiLinearRing;
 
 SWIGINTERN void delete_GeosMultiLinearRing(GeosMultiLinearRing *self){
         GEOSGeom geom = (GEOSGeom) self;
@@ -5466,7 +7633,7 @@
     delete_GeosMultiLinearRing(arg1);
 }
 
-swig_class cMultiPolygon;
+swig_class SwigClassMultiPolygon;
 
 SWIGINTERN void delete_GeosMultiPolygon(GeosMultiPolygon *self){
         GEOSGeom geom = (GEOSGeom) self;
@@ -5480,8 +7647,8 @@
 SWIGINTERN VALUE
 _wrap_create_point(int argc, VALUE *argv, VALUE self) {
   GeosCoordinateSequence *arg1 = (GeosCoordinateSequence *) 0 ;
-  GeosGeometry *result = 0 ;
   int res1 = 0 ;
+  GeosGeometry *result = 0 ;
   VALUE vresult = Qnil;
   
   if ((argc < 1) || (argc > 1)) {
@@ -5489,7 +7656,7 @@
   }
   res1 = SWIG_ConvertPtr(argv[0], SWIG_as_voidptrptr(&arg1), SWIGTYPE_p_GeosCoordinateSequence, SWIG_POINTER_DISOWN |  0 );
   if (!SWIG_IsOK(res1)) {
-    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "createPoint" "', argument " "1"" of type '" "GeosCoordinateSequence *""'");
+    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "GeosCoordinateSequence *","createPoint", 1, argv[0] ));
   }
   {
     try
@@ -5547,8 +7714,8 @@
 SWIGINTERN VALUE
 _wrap_create_line_string(int argc, VALUE *argv, VALUE self) {
   GeosCoordinateSequence *arg1 = (GeosCoordinateSequence *) 0 ;
-  GeosGeometry *result = 0 ;
   int res1 = 0 ;
+  GeosGeometry *result = 0 ;
   VALUE vresult = Qnil;
   
   if ((argc < 1) || (argc > 1)) {
@@ -5556,7 +7723,7 @@
   }
   res1 = SWIG_ConvertPtr(argv[0], SWIG_as_voidptrptr(&arg1), SWIGTYPE_p_GeosCoordinateSequence, SWIG_POINTER_DISOWN |  0 );
   if (!SWIG_IsOK(res1)) {
-    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "createLineString" "', argument " "1"" of type '" "GeosCoordinateSequence *""'");
+    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "GeosCoordinateSequence *","createLineString", 1, argv[0] ));
   }
   {
     try
@@ -5614,8 +7781,8 @@
 SWIGINTERN VALUE
 _wrap_create_linear_ring(int argc, VALUE *argv, VALUE self) {
   GeosCoordinateSequence *arg1 = (GeosCoordinateSequence *) 0 ;
-  GeosGeometry *result = 0 ;
   int res1 = 0 ;
+  GeosGeometry *result = 0 ;
   VALUE vresult = Qnil;
   
   if ((argc < 1) || (argc > 1)) {
@@ -5623,7 +7790,7 @@
   }
   res1 = SWIG_ConvertPtr(argv[0], SWIG_as_voidptrptr(&arg1), SWIGTYPE_p_GeosCoordinateSequence, SWIG_POINTER_DISOWN |  0 );
   if (!SWIG_IsOK(res1)) {
-    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "createLinearRing" "', argument " "1"" of type '" "GeosCoordinateSequence *""'");
+    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "GeosCoordinateSequence *","createLinearRing", 1, argv[0] ));
   }
   {
     try
@@ -5683,8 +7850,8 @@
   GeosLinearRing *arg1 = (GeosLinearRing *) 0 ;
   GeosLinearRing **arg2 = (GeosLinearRing **) 0 ;
   size_t arg3 ;
-  GeosGeometry *result = 0 ;
   int res1 = 0 ;
+  GeosGeometry *result = 0 ;
   VALUE vresult = Qnil;
   
   {
@@ -5696,7 +7863,7 @@
   }
   res1 = SWIG_ConvertPtr(argv[0], SWIG_as_voidptrptr(&arg1), SWIGTYPE_p_GeosLinearRing, SWIG_POINTER_DISOWN |  0 );
   if (!SWIG_IsOK(res1)) {
-    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "createPolygon" "', argument " "1"" of type '" "GeosLinearRing *""'");
+    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "GeosLinearRing *","createPolygon", 1, argv[0] ));
   }
   if (argc > 1) {
     {
@@ -5711,7 +7878,7 @@
         Check_Type(argv[1], T_ARRAY);
         
         /* Get the length */
-        arg3 = RARRAY(argv[1])->len;
+        arg3 = RARRAY_LEN(argv[1]);
         
         /* Allocate space for the C array. */
         arg2 = (GeosLinearRing**) malloc(arg3*sizeof(GeosLinearRing*));
@@ -5797,7 +7964,473 @@
 }
 
 
-swig_class cWktReader;
+swig_class SwigClassPrepared;
+
+#ifdef HAVE_RB_DEFINE_ALLOC_FUNC
+SWIGINTERN VALUE
+_wrap_Prepared_allocate(VALUE self) {
+#else
+  SWIGINTERN VALUE
+  _wrap_Prepared_allocate(int argc, VALUE *argv, VALUE self) {
+#endif
+    
+    
+    VALUE vresult = SWIG_NewClassInstance(self, SWIGTYPE_p_GeosPreparedGeometry);
+#ifndef HAVE_RB_DEFINE_ALLOC_FUNC
+    rb_obj_call_init(vresult, argc, argv);
+#endif
+    return vresult;
+  }
+  
+
+SWIGINTERN VALUE
+_wrap_new_Prepared(int argc, VALUE *argv, VALUE self) {
+  GeosGeometry *arg1 = (GeosGeometry *) 0 ;
+  void *argp1 = 0 ;
+  int res1 = 0 ;
+  GeosPreparedGeometry *result = 0 ;
+  
+  if ((argc < 1) || (argc > 1)) {
+    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc); SWIG_fail;
+  }
+  res1 = SWIG_ConvertPtr(argv[0], &argp1,SWIGTYPE_p_GeosGeometry, 0 |  0 );
+  if (!SWIG_IsOK(res1)) {
+    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "GeosGeometry const *","GeosPreparedGeometry", 1, argv[0] )); 
+  }
+  arg1 = reinterpret_cast< GeosGeometry * >(argp1);
+  {
+    try
+    {
+      result = (GeosPreparedGeometry *)new_GeosPreparedGeometry((GeosGeometry const *)arg1);
+      DATA_PTR(self) = result;
+    }
+    catch (const std::exception& e)
+    {
+      SWIG_exception(SWIG_RuntimeError, e.what());
+    }
+  }
+  return self;
+fail:
+  return Qnil;
+}
+
+
+SWIGINTERN void delete_GeosPreparedGeometry(GeosPreparedGeometry *self){
+        GEOSPreparedGeometry *prep = (GEOSPreparedGeometry *) self;
+        return GEOSPreparedGeom_destroy(prep);
+    }
+SWIGINTERN void
+free_GeosPreparedGeometry(GeosPreparedGeometry *arg1) {
+    delete_GeosPreparedGeometry(arg1);
+}
+
+SWIGINTERN VALUE
+_wrap_Prepared_containsq___(int argc, VALUE *argv, VALUE self) {
+  GeosPreparedGeometry *arg1 = (GeosPreparedGeometry *) 0 ;
+  GeosGeometry *arg2 = (GeosGeometry *) 0 ;
+  void *argp1 = 0 ;
+  int res1 = 0 ;
+  void *argp2 = 0 ;
+  int res2 = 0 ;
+  bool result;
+  VALUE vresult = Qnil;
+  
+  if ((argc < 1) || (argc > 1)) {
+    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc); SWIG_fail;
+  }
+  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_GeosPreparedGeometry, 0 |  0 );
+  if (!SWIG_IsOK(res1)) {
+    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "GeosPreparedGeometry *","contains", 1, self )); 
+  }
+  arg1 = reinterpret_cast< GeosPreparedGeometry * >(argp1);
+  res2 = SWIG_ConvertPtr(argv[0], &argp2,SWIGTYPE_p_GeosGeometry, 0 |  0 );
+  if (!SWIG_IsOK(res2)) {
+    SWIG_exception_fail(SWIG_ArgError(res2), Ruby_Format_TypeError( "", "GeosGeometry const *","contains", 2, argv[0] )); 
+  }
+  arg2 = reinterpret_cast< GeosGeometry * >(argp2);
+  {
+    try
+    {
+      result = (bool)GeosPreparedGeometry_contains(arg1,(GeosGeometry const *)arg2);
+    }
+    catch (const std::exception& e)
+    {
+      SWIG_exception(SWIG_RuntimeError, e.what());
+    }
+  }
+  vresult = (result ? Qtrue : Qfalse);
+  return vresult;
+fail:
+  return Qnil;
+}
+
+
+SWIGINTERN VALUE
+_wrap_Prepared_contains_properlyq___(int argc, VALUE *argv, VALUE self) {
+  GeosPreparedGeometry *arg1 = (GeosPreparedGeometry *) 0 ;
+  GeosGeometry *arg2 = (GeosGeometry *) 0 ;
+  void *argp1 = 0 ;
+  int res1 = 0 ;
+  void *argp2 = 0 ;
+  int res2 = 0 ;
+  bool result;
+  VALUE vresult = Qnil;
+  
+  if ((argc < 1) || (argc > 1)) {
+    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc); SWIG_fail;
+  }
+  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_GeosPreparedGeometry, 0 |  0 );
+  if (!SWIG_IsOK(res1)) {
+    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "GeosPreparedGeometry *","containsProperly", 1, self )); 
+  }
+  arg1 = reinterpret_cast< GeosPreparedGeometry * >(argp1);
+  res2 = SWIG_ConvertPtr(argv[0], &argp2,SWIGTYPE_p_GeosGeometry, 0 |  0 );
+  if (!SWIG_IsOK(res2)) {
+    SWIG_exception_fail(SWIG_ArgError(res2), Ruby_Format_TypeError( "", "GeosGeometry const *","containsProperly", 2, argv[0] )); 
+  }
+  arg2 = reinterpret_cast< GeosGeometry * >(argp2);
+  {
+    try
+    {
+      result = (bool)GeosPreparedGeometry_containsProperly(arg1,(GeosGeometry const *)arg2);
+    }
+    catch (const std::exception& e)
+    {
+      SWIG_exception(SWIG_RuntimeError, e.what());
+    }
+  }
+  vresult = SWIG_From_bool(static_cast< bool >(result));
+  return vresult;
+fail:
+  return Qnil;
+}
+
+
+SWIGINTERN VALUE
+_wrap_Prepared_coversq___(int argc, VALUE *argv, VALUE self) {
+  GeosPreparedGeometry *arg1 = (GeosPreparedGeometry *) 0 ;
+  GeosGeometry *arg2 = (GeosGeometry *) 0 ;
+  void *argp1 = 0 ;
+  int res1 = 0 ;
+  void *argp2 = 0 ;
+  int res2 = 0 ;
+  bool result;
+  VALUE vresult = Qnil;
+  
+  if ((argc < 1) || (argc > 1)) {
+    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc); SWIG_fail;
+  }
+  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_GeosPreparedGeometry, 0 |  0 );
+  if (!SWIG_IsOK(res1)) {
+    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "GeosPreparedGeometry *","covers", 1, self )); 
+  }
+  arg1 = reinterpret_cast< GeosPreparedGeometry * >(argp1);
+  res2 = SWIG_ConvertPtr(argv[0], &argp2,SWIGTYPE_p_GeosGeometry, 0 |  0 );
+  if (!SWIG_IsOK(res2)) {
+    SWIG_exception_fail(SWIG_ArgError(res2), Ruby_Format_TypeError( "", "GeosGeometry const *","covers", 2, argv[0] )); 
+  }
+  arg2 = reinterpret_cast< GeosGeometry * >(argp2);
+  {
+    try
+    {
+      result = (bool)GeosPreparedGeometry_covers(arg1,(GeosGeometry const *)arg2);
+    }
+    catch (const std::exception& e)
+    {
+      SWIG_exception(SWIG_RuntimeError, e.what());
+    }
+  }
+  vresult = (result ? Qtrue : Qfalse);
+  return vresult;
+fail:
+  return Qnil;
+}
+
+
+SWIGINTERN VALUE
+_wrap_Prepared_intersectsq___(int argc, VALUE *argv, VALUE self) {
+  GeosPreparedGeometry *arg1 = (GeosPreparedGeometry *) 0 ;
+  GeosGeometry *arg2 = (GeosGeometry *) 0 ;
+  void *argp1 = 0 ;
+  int res1 = 0 ;
+  void *argp2 = 0 ;
+  int res2 = 0 ;
+  bool result;
+  VALUE vresult = Qnil;
+  
+  if ((argc < 1) || (argc > 1)) {
+    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc); SWIG_fail;
+  }
+  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_GeosPreparedGeometry, 0 |  0 );
+  if (!SWIG_IsOK(res1)) {
+    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "GeosPreparedGeometry *","intersects", 1, self )); 
+  }
+  arg1 = reinterpret_cast< GeosPreparedGeometry * >(argp1);
+  res2 = SWIG_ConvertPtr(argv[0], &argp2,SWIGTYPE_p_GeosGeometry, 0 |  0 );
+  if (!SWIG_IsOK(res2)) {
+    SWIG_exception_fail(SWIG_ArgError(res2), Ruby_Format_TypeError( "", "GeosGeometry const *","intersects", 2, argv[0] )); 
+  }
+  arg2 = reinterpret_cast< GeosGeometry * >(argp2);
+  {
+    try
+    {
+      result = (bool)GeosPreparedGeometry_intersects(arg1,(GeosGeometry const *)arg2);
+    }
+    catch (const std::exception& e)
+    {
+      SWIG_exception(SWIG_RuntimeError, e.what());
+    }
+  }
+  vresult = (result ? Qtrue : Qfalse);
+  return vresult;
+fail:
+  return Qnil;
+}
+
+
+swig_class SwigClassSTRtree;
+
+#ifdef HAVE_RB_DEFINE_ALLOC_FUNC
+SWIGINTERN VALUE
+_wrap_STRtree_allocate(VALUE self) {
+#else
+  SWIGINTERN VALUE
+  _wrap_STRtree_allocate(int argc, VALUE *argv, VALUE self) {
+#endif
+    
+    
+    VALUE vresult = SWIG_NewClassInstance(self, SWIGTYPE_p_GeosSTRtree);
+#ifndef HAVE_RB_DEFINE_ALLOC_FUNC
+    rb_obj_call_init(vresult, argc, argv);
+#endif
+    return vresult;
+  }
+  
+
+SWIGINTERN VALUE
+_wrap_new_STRtree(int argc, VALUE *argv, VALUE self) {
+  int arg1 ;
+  int val1 ;
+  int ecode1 = 0 ;
+  GeosSTRtree *result = 0 ;
+  
+  {
+    arg1 = 10;
+  }
+  if ((argc < 0) || (argc > 1)) {
+    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;
+  }
+  if (argc > 0) {
+    ecode1 = SWIG_AsVal_int(argv[0], &val1);
+    if (!SWIG_IsOK(ecode1)) {
+      SWIG_exception_fail(SWIG_ArgError(ecode1), Ruby_Format_TypeError( "", "int","GeosSTRtree", 1, argv[0] ));
+    } 
+    arg1 = static_cast< int >(val1);
+  }
+  {
+    try
+    {
+      result = (GeosSTRtree *)new_GeosSTRtree(arg1);
+      DATA_PTR(self) = result;
+    }
+    catch (const std::exception& e)
+    {
+      SWIG_exception(SWIG_RuntimeError, e.what());
+    }
+  }
+  return self;
+fail:
+  return Qnil;
+}
+
+
+SWIGINTERN void delete_GeosSTRtree(GeosSTRtree *self){
+        GEOSSTRtree *tree = (GEOSSTRtree *) self;
+        return GEOSSTRtree_destroy(tree);
+    }
+SWIGINTERN void
+free_GeosSTRtree(GeosSTRtree *arg1) {
+    delete_GeosSTRtree(arg1);
+}
+
+
+/*
+  Document-method: Geos::STRtree.insert
+
+  call-seq:
+    insert(g, item)
+
+Insert one or more new elements in the STRtree.
+*/
+SWIGINTERN VALUE
+_wrap_STRtree_insert(int argc, VALUE *argv, VALUE self) {
+  GeosSTRtree *arg1 = (GeosSTRtree *) 0 ;
+  GeosGeometry *arg2 = (GeosGeometry *) 0 ;
+  GeosIndexItem arg3 ;
+  void *argp1 = 0 ;
+  int res1 = 0 ;
+  void *argp2 = 0 ;
+  int res2 = 0 ;
+  
+  if ((argc < 2) || (argc > 2)) {
+    rb_raise(rb_eArgError, "wrong # of arguments(%d for 2)",argc); SWIG_fail;
+  }
+  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_GeosSTRtree, 0 |  0 );
+  if (!SWIG_IsOK(res1)) {
+    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "GeosSTRtree *","insert", 1, self )); 
+  }
+  arg1 = reinterpret_cast< GeosSTRtree * >(argp1);
+  res2 = SWIG_ConvertPtr(argv[0], &argp2,SWIGTYPE_p_GeosGeometry, 0 |  0 );
+  if (!SWIG_IsOK(res2)) {
+    SWIG_exception_fail(SWIG_ArgError(res2), Ruby_Format_TypeError( "", "GeosGeometry const *","insert", 2, argv[0] )); 
+  }
+  arg2 = reinterpret_cast< GeosGeometry * >(argp2);
+  {
+    arg3 = (GeosIndexItem) argv[1];
+  }
+  {
+    try
+    {
+      GeosSTRtree_insert(arg1,(GeosGeometry const *)arg2,arg3);
+    }
+    catch (const std::exception& e)
+    {
+      SWIG_exception(SWIG_RuntimeError, e.what());
+    }
+  }
+  return Qnil;
+fail:
+  return Qnil;
+}
+
+
+SWIGINTERN VALUE
+_wrap_STRtree_remove(int argc, VALUE *argv, VALUE self) {
+  GeosSTRtree *arg1 = (GeosSTRtree *) 0 ;
+  GeosGeometry *arg2 = (GeosGeometry *) 0 ;
+  GeosIndexItem arg3 ;
+  void *argp1 = 0 ;
+  int res1 = 0 ;
+  void *argp2 = 0 ;
+  int res2 = 0 ;
+  
+  if ((argc < 2) || (argc > 2)) {
+    rb_raise(rb_eArgError, "wrong # of arguments(%d for 2)",argc); SWIG_fail;
+  }
+  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_GeosSTRtree, 0 |  0 );
+  if (!SWIG_IsOK(res1)) {
+    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "GeosSTRtree *","remove", 1, self )); 
+  }
+  arg1 = reinterpret_cast< GeosSTRtree * >(argp1);
+  res2 = SWIG_ConvertPtr(argv[0], &argp2,SWIGTYPE_p_GeosGeometry, 0 |  0 );
+  if (!SWIG_IsOK(res2)) {
+    SWIG_exception_fail(SWIG_ArgError(res2), Ruby_Format_TypeError( "", "GeosGeometry const *","remove", 2, argv[0] )); 
+  }
+  arg2 = reinterpret_cast< GeosGeometry * >(argp2);
+  {
+    arg3 = (GeosIndexItem) argv[1];
+  }
+  {
+    try
+    {
+      GeosSTRtree_remove(arg1,(GeosGeometry const *)arg2,arg3);
+    }
+    catch (const std::exception& e)
+    {
+      SWIG_exception(SWIG_RuntimeError, e.what());
+    }
+  }
+  return Qnil;
+fail:
+  return Qnil;
+}
+
+
+SWIGINTERN VALUE
+_wrap_STRtree_query(int argc, VALUE *argv, VALUE self) {
+  GeosSTRtree *arg1 = (GeosSTRtree *) 0 ;
+  GeosGeometry *arg2 = (GeosGeometry *) 0 ;
+  GeosQueryCallback arg3 ;
+  GeosIndexItem arg4 ;
+  void *argp1 = 0 ;
+  int res1 = 0 ;
+  void *argp2 = 0 ;
+  int res2 = 0 ;
+  
+  {
+    arg3 = GeosSTRtree_query_callback;
+  }
+  {
+    arg4 = (GeosIndexItem) Qnil;
+  }
+  if ((argc < 1) || (argc > 1)) {
+    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc); SWIG_fail;
+  }
+  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_GeosSTRtree, 0 |  0 );
+  if (!SWIG_IsOK(res1)) {
+    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "GeosSTRtree *","query", 1, self )); 
+  }
+  arg1 = reinterpret_cast< GeosSTRtree * >(argp1);
+  res2 = SWIG_ConvertPtr(argv[0], &argp2,SWIGTYPE_p_GeosGeometry, 0 |  0 );
+  if (!SWIG_IsOK(res2)) {
+    SWIG_exception_fail(SWIG_ArgError(res2), Ruby_Format_TypeError( "", "GeosGeometry const *","query", 2, argv[0] )); 
+  }
+  arg2 = reinterpret_cast< GeosGeometry * >(argp2);
+  {
+    try
+    {
+      GeosSTRtree_query(arg1,(GeosGeometry const *)arg2,arg3,arg4);
+    }
+    catch (const std::exception& e)
+    {
+      SWIG_exception(SWIG_RuntimeError, e.what());
+    }
+  }
+  return Qnil;
+fail:
+  return Qnil;
+}
+
+
+SWIGINTERN VALUE
+_wrap_STRtree_each(int argc, VALUE *argv, VALUE self) {
+  GeosSTRtree *arg1 = (GeosSTRtree *) 0 ;
+  GeosQueryCallback arg2 ;
+  GeosIndexItem arg3 ;
+  void *argp1 = 0 ;
+  int res1 = 0 ;
+  
+  {
+    arg2 = GeosSTRtree_query_callback;
+  }
+  {
+    arg3 = (GeosIndexItem) Qnil;
+  }
+  if ((argc < 0) || (argc > 0)) {
+    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;
+  }
+  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_GeosSTRtree, 0 |  0 );
+  if (!SWIG_IsOK(res1)) {
+    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "GeosSTRtree *","iterate", 1, self )); 
+  }
+  arg1 = reinterpret_cast< GeosSTRtree * >(argp1);
+  {
+    try
+    {
+      GeosSTRtree_iterate(arg1,arg2,arg3);
+    }
+    catch (const std::exception& e)
+    {
+      SWIG_exception(SWIG_RuntimeError, e.what());
+    }
+  }
+  return Qnil;
+fail:
+  return Qnil;
+}
+
+
+swig_class SwigClassWktReader;
 
 #ifdef HAVE_RB_DEFINE_ALLOC_FUNC
 SWIGINTERN VALUE
@@ -5826,8 +8459,8 @@
   {
     try
     {
-      result = (GeosWktReader *)new_GeosWktReader();DATA_PTR(self) = result;
-      
+      result = (GeosWktReader *)new_GeosWktReader();
+      DATA_PTR(self) = result;
     }
     catch (const std::exception& e)
     {
@@ -5853,12 +8486,12 @@
 _wrap_WktReader_read(int argc, VALUE *argv, VALUE self) {
   GeosWktReader *arg1 = (GeosWktReader *) 0 ;
   char *arg2 = (char *) 0 ;
-  GeosGeometry *result = 0 ;
   void *argp1 = 0 ;
   int res1 = 0 ;
   int res2 ;
   char *buf2 = 0 ;
   int alloc2 = 0 ;
+  GeosGeometry *result = 0 ;
   VALUE vresult = Qnil;
   
   if ((argc < 1) || (argc > 1)) {
@@ -5866,12 +8499,12 @@
   }
   res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_GeosWktReader, 0 |  0 );
   if (!SWIG_IsOK(res1)) {
-    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "read" "', argument " "1"" of type '" "GeosWktReader *""'"); 
+    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "GeosWktReader *","read", 1, self )); 
   }
   arg1 = reinterpret_cast< GeosWktReader * >(argp1);
   res2 = SWIG_AsCharPtrAndSize(argv[0], &buf2, NULL, &alloc2);
   if (!SWIG_IsOK(res2)) {
-    SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "read" "', argument " "2"" of type '" "char const *""'");
+    SWIG_exception_fail(SWIG_ArgError(res2), Ruby_Format_TypeError( "", "char const *","read", 2, argv[0] ));
   }
   arg2 = reinterpret_cast< char * >(buf2);
   {
@@ -5929,7 +8562,7 @@
 }
 
 
-swig_class cWktWriter;
+swig_class SwigClassWktWriter;
 
 #ifdef HAVE_RB_DEFINE_ALLOC_FUNC
 SWIGINTERN VALUE
@@ -5958,8 +8591,8 @@
   {
     try
     {
-      result = (GeosWktWriter *)new_GeosWktWriter();DATA_PTR(self) = result;
-      
+      result = (GeosWktWriter *)new_GeosWktWriter();
+      DATA_PTR(self) = result;
     }
     catch (const std::exception& e)
     {
@@ -5985,11 +8618,11 @@
 _wrap_WktWriter_write(int argc, VALUE *argv, VALUE self) {
   GeosWktWriter *arg1 = (GeosWktWriter *) 0 ;
   GeosGeometry *arg2 = (GeosGeometry *) 0 ;
-  char *result = 0 ;
   void *argp1 = 0 ;
   int res1 = 0 ;
   void *argp2 = 0 ;
   int res2 = 0 ;
+  char *result = 0 ;
   VALUE vresult = Qnil;
   
   if ((argc < 1) || (argc > 1)) {
@@ -5997,12 +8630,12 @@
   }
   res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_GeosWktWriter, 0 |  0 );
   if (!SWIG_IsOK(res1)) {
-    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "write" "', argument " "1"" of type '" "GeosWktWriter *""'"); 
+    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "GeosWktWriter *","write", 1, self )); 
   }
   arg1 = reinterpret_cast< GeosWktWriter * >(argp1);
   res2 = SWIG_ConvertPtr(argv[0], &argp2,SWIGTYPE_p_GeosGeometry, 0 |  0 );
   if (!SWIG_IsOK(res2)) {
-    SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "write" "', argument " "2"" of type '" "GeosGeometry const *""'"); 
+    SWIG_exception_fail(SWIG_ArgError(res2), Ruby_Format_TypeError( "", "GeosGeometry const *","write", 2, argv[0] )); 
   }
   arg2 = reinterpret_cast< GeosGeometry * >(argp2);
   {
@@ -6022,7 +8655,7 @@
 }
 
 
-swig_class cWkbReader;
+swig_class SwigClassWkbReader;
 
 #ifdef HAVE_RB_DEFINE_ALLOC_FUNC
 SWIGINTERN VALUE
@@ -6051,8 +8684,8 @@
   {
     try
     {
-      result = (GeosWkbReader *)new_GeosWkbReader();DATA_PTR(self) = result;
-      
+      result = (GeosWkbReader *)new_GeosWkbReader();
+      DATA_PTR(self) = result;
     }
     catch (const std::exception& e)
     {
@@ -6079,10 +8712,10 @@
   GeosWkbReader *arg1 = (GeosWkbReader *) 0 ;
   unsigned char *arg2 = (unsigned char *) 0 ;
   size_t arg3 ;
-  GeosGeometry *result = 0 ;
   void *argp1 = 0 ;
   int res1 = 0 ;
   int alloc2 = 0 ;
+  GeosGeometry *result = 0 ;
   VALUE vresult = Qnil;
   
   if ((argc < 1) || (argc > 1)) {
@@ -6090,7 +8723,7 @@
   }
   res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_GeosWkbReader, 0 |  0 );
   if (!SWIG_IsOK(res1)) {
-    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "read" "', argument " "1"" of type '" "GeosWkbReader *""'"); 
+    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "GeosWkbReader *","read", 1, self )); 
   }
   arg1 = reinterpret_cast< GeosWkbReader * >(argp1);
   {
@@ -6158,10 +8791,10 @@
   GeosWkbReader *arg1 = (GeosWkbReader *) 0 ;
   unsigned char *arg2 = (unsigned char *) 0 ;
   size_t arg3 ;
-  GeosGeometry *result = 0 ;
   void *argp1 = 0 ;
   int res1 = 0 ;
   int alloc2 = 0 ;
+  GeosGeometry *result = 0 ;
   VALUE vresult = Qnil;
   
   if ((argc < 1) || (argc > 1)) {
@@ -6169,7 +8802,7 @@
   }
   res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_GeosWkbReader, 0 |  0 );
   if (!SWIG_IsOK(res1)) {
-    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "readHEX" "', argument " "1"" of type '" "GeosWkbReader *""'"); 
+    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "GeosWkbReader *","readHEX", 1, self )); 
   }
   arg1 = reinterpret_cast< GeosWkbReader * >(argp1);
   {
@@ -6232,7 +8865,7 @@
 }
 
 
-swig_class cWkbWriter;
+swig_class SwigClassWkbWriter;
 
 #ifdef HAVE_RB_DEFINE_ALLOC_FUNC
 SWIGINTERN VALUE
@@ -6261,8 +8894,8 @@
   {
     try
     {
-      result = (GeosWkbWriter *)new_GeosWkbWriter();DATA_PTR(self) = result;
-      
+      result = (GeosWkbWriter *)new_GeosWkbWriter();
+      DATA_PTR(self) = result;
     }
     catch (const std::exception& e)
     {
@@ -6287,9 +8920,9 @@
 SWIGINTERN VALUE
 _wrap_WkbWriter_output_dimensions(int argc, VALUE *argv, VALUE self) {
   GeosWkbWriter *arg1 = (GeosWkbWriter *) 0 ;
-  int result;
   void *argp1 = 0 ;
   int res1 = 0 ;
+  int result;
   VALUE vresult = Qnil;
   
   if ((argc < 0) || (argc > 0)) {
@@ -6297,7 +8930,7 @@
   }
   res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_GeosWkbWriter, 0 |  0 );
   if (!SWIG_IsOK(res1)) {
-    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "getOutputDimension" "', argument " "1"" of type '" "GeosWkbWriter *""'"); 
+    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "GeosWkbWriter *","getOutputDimension", 1, self )); 
   }
   arg1 = reinterpret_cast< GeosWkbWriter * >(argp1);
   {
@@ -6331,12 +8964,12 @@
   }
   res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_GeosWkbWriter, 0 |  0 );
   if (!SWIG_IsOK(res1)) {
-    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "setOutputDimension" "', argument " "1"" of type '" "GeosWkbWriter *""'"); 
+    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "GeosWkbWriter *","setOutputDimension", 1, self )); 
   }
   arg1 = reinterpret_cast< GeosWkbWriter * >(argp1);
   ecode2 = SWIG_AsVal_int(argv[0], &val2);
   if (!SWIG_IsOK(ecode2)) {
-    SWIG_exception_fail(SWIG_ArgError(ecode2), "in method '" "setOutputDimension" "', argument " "2"" of type '" "int""'");
+    SWIG_exception_fail(SWIG_ArgError(ecode2), Ruby_Format_TypeError( "", "int","setOutputDimension", 2, argv[0] ));
   } 
   arg2 = static_cast< int >(val2);
   {
@@ -6358,9 +8991,9 @@
 SWIGINTERN VALUE
 _wrap_WkbWriter_byte_order(int argc, VALUE *argv, VALUE self) {
   GeosWkbWriter *arg1 = (GeosWkbWriter *) 0 ;
-  int result;
   void *argp1 = 0 ;
   int res1 = 0 ;
+  int result;
   VALUE vresult = Qnil;
   
   if ((argc < 0) || (argc > 0)) {
@@ -6368,7 +9001,7 @@
   }
   res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_GeosWkbWriter, 0 |  0 );
   if (!SWIG_IsOK(res1)) {
-    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "getByteOrder" "', argument " "1"" of type '" "GeosWkbWriter *""'"); 
+    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "GeosWkbWriter *","getByteOrder", 1, self )); 
   }
   arg1 = reinterpret_cast< GeosWkbWriter * >(argp1);
   {
@@ -6402,12 +9035,12 @@
   }
   res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_GeosWkbWriter, 0 |  0 );
   if (!SWIG_IsOK(res1)) {
-    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "setByteOrder" "', argument " "1"" of type '" "GeosWkbWriter *""'"); 
+    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "GeosWkbWriter *","setByteOrder", 1, self )); 
   }
   arg1 = reinterpret_cast< GeosWkbWriter * >(argp1);
   ecode2 = SWIG_AsVal_int(argv[0], &val2);
   if (!SWIG_IsOK(ecode2)) {
-    SWIG_exception_fail(SWIG_ArgError(ecode2), "in method '" "setByteOrder" "', argument " "2"" of type '" "int""'");
+    SWIG_exception_fail(SWIG_ArgError(ecode2), Ruby_Format_TypeError( "", "int","setByteOrder", 2, argv[0] ));
   } 
   arg2 = static_cast< int >(val2);
   {
@@ -6429,9 +9062,9 @@
 SWIGINTERN VALUE
 _wrap_WkbWriter_include_srid(int argc, VALUE *argv, VALUE self) {
   GeosWkbWriter *arg1 = (GeosWkbWriter *) 0 ;
-  bool result;
   void *argp1 = 0 ;
   int res1 = 0 ;
+  bool result;
   VALUE vresult = Qnil;
   
   if ((argc < 0) || (argc > 0)) {
@@ -6439,7 +9072,7 @@
   }
   res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_GeosWkbWriter, 0 |  0 );
   if (!SWIG_IsOK(res1)) {
-    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "getIncludeSRID" "', argument " "1"" of type '" "GeosWkbWriter *""'"); 
+    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "GeosWkbWriter *","getIncludeSRID", 1, self )); 
   }
   arg1 = reinterpret_cast< GeosWkbWriter * >(argp1);
   {
@@ -6473,12 +9106,12 @@
   }
   res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_GeosWkbWriter, 0 |  0 );
   if (!SWIG_IsOK(res1)) {
-    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "setIncludeSRID" "', argument " "1"" of type '" "GeosWkbWriter *""'"); 
+    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "GeosWkbWriter *","setIncludeSRID", 1, self )); 
   }
   arg1 = reinterpret_cast< GeosWkbWriter * >(argp1);
   ecode2 = SWIG_AsVal_bool(argv[0], &val2);
   if (!SWIG_IsOK(ecode2)) {
-    SWIG_exception_fail(SWIG_ArgError(ecode2), "in method '" "setIncludeSRID" "', argument " "2"" of type '" "bool""'");
+    SWIG_exception_fail(SWIG_ArgError(ecode2), Ruby_Format_TypeError( "", "bool","setIncludeSRID", 2, argv[0] ));
   } 
   arg2 = static_cast< bool >(val2);
   {
@@ -6502,12 +9135,12 @@
   GeosWkbWriter *arg1 = (GeosWkbWriter *) 0 ;
   GeosGeometry *arg2 = (GeosGeometry *) 0 ;
   size_t *arg3 = (size_t *) 0 ;
-  unsigned char *result = 0 ;
   void *argp1 = 0 ;
   int res1 = 0 ;
   void *argp2 = 0 ;
   int res2 = 0 ;
   size_t temp3 = 0 ;
+  unsigned char *result = 0 ;
   VALUE vresult = Qnil;
   
   {
@@ -6519,12 +9152,12 @@
   }
   res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_GeosWkbWriter, 0 |  0 );
   if (!SWIG_IsOK(res1)) {
-    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "write" "', argument " "1"" of type '" "GeosWkbWriter *""'"); 
+    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "GeosWkbWriter *","write", 1, self )); 
   }
   arg1 = reinterpret_cast< GeosWkbWriter * >(argp1);
   res2 = SWIG_ConvertPtr(argv[0], &argp2,SWIGTYPE_p_GeosGeometry, 0 |  0 );
   if (!SWIG_IsOK(res2)) {
-    SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "write" "', argument " "2"" of type '" "GeosGeometry const *""'"); 
+    SWIG_exception_fail(SWIG_ArgError(res2), Ruby_Format_TypeError( "", "GeosGeometry const *","write", 2, argv[0] )); 
   }
   arg2 = reinterpret_cast< GeosGeometry * >(argp2);
   {
@@ -6563,12 +9196,12 @@
   GeosWkbWriter *arg1 = (GeosWkbWriter *) 0 ;
   GeosGeometry *arg2 = (GeosGeometry *) 0 ;
   size_t *arg3 = (size_t *) 0 ;
-  unsigned char *result = 0 ;
   void *argp1 = 0 ;
   int res1 = 0 ;
   void *argp2 = 0 ;
   int res2 = 0 ;
   size_t temp3 = 0 ;
+  unsigned char *result = 0 ;
   VALUE vresult = Qnil;
   
   {
@@ -6580,12 +9213,12 @@
   }
   res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_GeosWkbWriter, 0 |  0 );
   if (!SWIG_IsOK(res1)) {
-    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "writeHEX" "', argument " "1"" of type '" "GeosWkbWriter *""'"); 
+    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "GeosWkbWriter *","writeHEX", 1, self )); 
   }
   arg1 = reinterpret_cast< GeosWkbWriter * >(argp1);
   res2 = SWIG_ConvertPtr(argv[0], &argp2,SWIGTYPE_p_GeosGeometry, 0 |  0 );
   if (!SWIG_IsOK(res2)) {
-    SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "writeHEX" "', argument " "2"" of type '" "GeosGeometry const *""'"); 
+    SWIG_exception_fail(SWIG_ArgError(res2), Ruby_Format_TypeError( "", "GeosGeometry const *","writeHEX", 2, argv[0] )); 
   }
   arg2 = reinterpret_cast< GeosGeometry * >(argp2);
   {
@@ -6622,45 +9255,48 @@
 
 /* -------- TYPE CONVERSION AND EQUIVALENCE RULES (BEGIN) -------- */
 
-static void *_p_GeosMultiPolygonTo_p_GeosGeometryCollection(void *x) {
+static void *_p_GeosMultiPolygonTo_p_GeosGeometryCollection(void *x, int *SWIGUNUSEDPARM(newmemory)) {
     return (void *)((GeosGeometryCollection *)  ((GeosMultiPolygon *) x));
 }
-static void *_p_GeosMultiPointTo_p_GeosGeometryCollection(void *x) {
+static void *_p_GeosMultiPointTo_p_GeosGeometryCollection(void *x, int *SWIGUNUSEDPARM(newmemory)) {
     return (void *)((GeosGeometryCollection *)  ((GeosMultiPoint *) x));
 }
-static void *_p_GeosMultiLineStringTo_p_GeosGeometryCollection(void *x) {
+static void *_p_GeosMultiLineStringTo_p_GeosGeometryCollection(void *x, int *SWIGUNUSEDPARM(newmemory)) {
     return (void *)((GeosGeometryCollection *)  ((GeosMultiLineString *) x));
 }
-static void *_p_GeosMultiLinearRingTo_p_GeosGeometryCollection(void *x) {
+static void *_p_GeosMultiLinearRingTo_p_GeosGeometryCollection(void *x, int *SWIGUNUSEDPARM(newmemory)) {
     return (void *)((GeosGeometryCollection *)  ((GeosMultiLinearRing *) x));
 }
-static void *_p_GeosPolygonTo_p_GeosGeometry(void *x) {
+static void *_p_GeosPolygonTo_p_GeosGeometry(void *x, int *SWIGUNUSEDPARM(newmemory)) {
     return (void *)((GeosGeometry *)  ((GeosPolygon *) x));
 }
-static void *_p_GeosMultiPolygonTo_p_GeosGeometry(void *x) {
+static void *_p_GeosMultiPolygonTo_p_GeosGeometry(void *x, int *SWIGUNUSEDPARM(newmemory)) {
     return (void *)((GeosGeometry *) (GeosGeometryCollection *) ((GeosMultiPolygon *) x));
 }
-static void *_p_GeosPointTo_p_GeosGeometry(void *x) {
+static void *_p_GeosPointTo_p_GeosGeometry(void *x, int *SWIGUNUSEDPARM(newmemory)) {
     return (void *)((GeosGeometry *)  ((GeosPoint *) x));
 }
-static void *_p_GeosLineStringTo_p_GeosGeometry(void *x) {
+static void *_p_GeosLineStringTo_p_GeosGeometry(void *x, int *SWIGUNUSEDPARM(newmemory)) {
     return (void *)((GeosGeometry *)  ((GeosLineString *) x));
 }
-static void *_p_GeosLinearRingTo_p_GeosGeometry(void *x) {
+static void *_p_GeosLinearRingTo_p_GeosGeometry(void *x, int *SWIGUNUSEDPARM(newmemory)) {
     return (void *)((GeosGeometry *)  ((GeosLinearRing *) x));
 }
-static void *_p_GeosMultiPointTo_p_GeosGeometry(void *x) {
+static void *_p_GeosMultiPointTo_p_GeosGeometry(void *x, int *SWIGUNUSEDPARM(newmemory)) {
     return (void *)((GeosGeometry *) (GeosGeometryCollection *) ((GeosMultiPoint *) x));
 }
-static void *_p_GeosMultiLineStringTo_p_GeosGeometry(void *x) {
+static void *_p_GeosMultiLineStringTo_p_GeosGeometry(void *x, int *SWIGUNUSEDPARM(newmemory)) {
     return (void *)((GeosGeometry *) (GeosGeometryCollection *) ((GeosMultiLineString *) x));
 }
-static void *_p_GeosMultiLinearRingTo_p_GeosGeometry(void *x) {
+static void *_p_GeosMultiLinearRingTo_p_GeosGeometry(void *x, int *SWIGUNUSEDPARM(newmemory)) {
     return (void *)((GeosGeometry *) (GeosGeometryCollection *) ((GeosMultiLinearRing *) x));
 }
-static void *_p_GeosGeometryCollectionTo_p_GeosGeometry(void *x) {
+static void *_p_GeosGeometryCollectionTo_p_GeosGeometry(void *x, int *SWIGUNUSEDPARM(newmemory)) {
     return (void *)((GeosGeometry *)  ((GeosGeometryCollection *) x));
 }
+static void *_p_swig__IteratorTo_p_swig__ConstIterator(void *x, int *SWIGUNUSEDPARM(newmemory)) {
+    return (void *)((swig::ConstIterator *)  ((swig::Iterator *) x));
+}
 static swig_type_info _swigt__p_GeosCoordinateSequence = {"_p_GeosCoordinateSequence", "GeosCoordinateSequence *", 0, 0, (void*)0, 0};
 static swig_type_info _swigt__p_GeosGeometry = {"_p_GeosGeometry", "GeosGeometry *", 0, 0, (void*)0, 0};
 static swig_type_info _swigt__p_GeosGeometryCollection = {"_p_GeosGeometryCollection", "GeosGeometryCollection *", 0, 0, (void*)0, 0};
@@ -6672,13 +9308,19 @@
 static swig_type_info _swigt__p_GeosMultiPolygon = {"_p_GeosMultiPolygon", "GeosMultiPolygon *", 0, 0, (void*)0, 0};
 static swig_type_info _swigt__p_GeosPoint = {"_p_GeosPoint", "GeosPoint *", 0, 0, (void*)0, 0};
 static swig_type_info _swigt__p_GeosPolygon = {"_p_GeosPolygon", "GeosPolygon *", 0, 0, (void*)0, 0};
+static swig_type_info _swigt__p_GeosPreparedGeometry = {"_p_GeosPreparedGeometry", "GeosPreparedGeometry *", 0, 0, (void*)0, 0};
+static swig_type_info _swigt__p_GeosSTRtree = {"_p_GeosSTRtree", "GeosSTRtree *", 0, 0, (void*)0, 0};
 static swig_type_info _swigt__p_GeosWkbReader = {"_p_GeosWkbReader", "GeosWkbReader *", 0, 0, (void*)0, 0};
 static swig_type_info _swigt__p_GeosWkbWriter = {"_p_GeosWkbWriter", "GeosWkbWriter *", 0, 0, (void*)0, 0};
 static swig_type_info _swigt__p_GeosWktReader = {"_p_GeosWktReader", "GeosWktReader *", 0, 0, (void*)0, 0};
 static swig_type_info _swigt__p_GeosWktWriter = {"_p_GeosWktWriter", "GeosWktWriter *", 0, 0, (void*)0, 0};
 static swig_type_info _swigt__p_char = {"_p_char", "char *", 0, 0, (void*)0, 0};
 static swig_type_info _swigt__p_p_GeosLinearRing = {"_p_p_GeosLinearRing", "GeosLinearRing **", 0, 0, (void*)0, 0};
+static swig_type_info _swigt__p_p_void = {"_p_p_void", "void **|VALUE *", 0, 0, (void*)0, 0};
 static swig_type_info _swigt__p_size_t = {"_p_size_t", "size_t *", 0, 0, (void*)0, 0};
+static swig_type_info _swigt__p_swig__ConstIterator = {"_p_swig__ConstIterator", "swig::ConstIterator *", 0, 0, (void*)0, 0};
+static swig_type_info _swigt__p_swig__GC_VALUE = {"_p_swig__GC_VALUE", "swig::GC_VALUE *", 0, 0, (void*)0, 0};
+static swig_type_info _swigt__p_swig__Iterator = {"_p_swig__Iterator", "swig::Iterator *", 0, 0, (void*)0, 0};
 static swig_type_info _swigt__p_unsigned_char = {"_p_unsigned_char", "unsigned char *", 0, 0, (void*)0, 0};
 
 static swig_type_info *swig_type_initial[] = {
@@ -6693,13 +9335,19 @@
   &_swigt__p_GeosMultiPolygon,
   &_swigt__p_GeosPoint,
   &_swigt__p_GeosPolygon,
+  &_swigt__p_GeosPreparedGeometry,
+  &_swigt__p_GeosSTRtree,
   &_swigt__p_GeosWkbReader,
   &_swigt__p_GeosWkbWriter,
   &_swigt__p_GeosWktReader,
   &_swigt__p_GeosWktWriter,
   &_swigt__p_char,
   &_swigt__p_p_GeosLinearRing,
+  &_swigt__p_p_void,
   &_swigt__p_size_t,
+  &_swigt__p_swig__ConstIterator,
+  &_swigt__p_swig__GC_VALUE,
+  &_swigt__p_swig__Iterator,
   &_swigt__p_unsigned_char,
 };
 
@@ -6714,13 +9362,19 @@
 static swig_cast_info _swigc__p_GeosMultiPolygon[] = {  {&_swigt__p_GeosMultiPolygon, 0, 0, 0},{0, 0, 0, 0}};
 static swig_cast_info _swigc__p_GeosPoint[] = {  {&_swigt__p_GeosPoint, 0, 0, 0},{0, 0, 0, 0}};
 static swig_cast_info _swigc__p_GeosPolygon[] = {  {&_swigt__p_GeosPolygon, 0, 0, 0},{0, 0, 0, 0}};
+static swig_cast_info _swigc__p_GeosPreparedGeometry[] = {  {&_swigt__p_GeosPreparedGeometry, 0, 0, 0},{0, 0, 0, 0}};
+static swig_cast_info _swigc__p_GeosSTRtree[] = {  {&_swigt__p_GeosSTRtree, 0, 0, 0},{0, 0, 0, 0}};
 static swig_cast_info _swigc__p_GeosWkbReader[] = {  {&_swigt__p_GeosWkbReader, 0, 0, 0},{0, 0, 0, 0}};
 static swig_cast_info _swigc__p_GeosWkbWriter[] = {  {&_swigt__p_GeosWkbWriter, 0, 0, 0},{0, 0, 0, 0}};
 static swig_cast_info _swigc__p_GeosWktReader[] = {  {&_swigt__p_GeosWktReader, 0, 0, 0},{0, 0, 0, 0}};
 static swig_cast_info _swigc__p_GeosWktWriter[] = {  {&_swigt__p_GeosWktWriter, 0, 0, 0},{0, 0, 0, 0}};
 static swig_cast_info _swigc__p_char[] = {  {&_swigt__p_char, 0, 0, 0},{0, 0, 0, 0}};
 static swig_cast_info _swigc__p_p_GeosLinearRing[] = {  {&_swigt__p_p_GeosLinearRing, 0, 0, 0},{0, 0, 0, 0}};
+static swig_cast_info _swigc__p_p_void[] = {  {&_swigt__p_p_void, 0, 0, 0},{0, 0, 0, 0}};
 static swig_cast_info _swigc__p_size_t[] = {  {&_swigt__p_size_t, 0, 0, 0},{0, 0, 0, 0}};
+static swig_cast_info _swigc__p_swig__ConstIterator[] = {  {&_swigt__p_swig__ConstIterator, 0, 0, 0},  {&_swigt__p_swig__Iterator, _p_swig__IteratorTo_p_swig__ConstIterator, 0, 0},{0, 0, 0, 0}};
+static swig_cast_info _swigc__p_swig__GC_VALUE[] = {  {&_swigt__p_swig__GC_VALUE, 0, 0, 0},{0, 0, 0, 0}};
+static swig_cast_info _swigc__p_swig__Iterator[] = {  {&_swigt__p_swig__Iterator, 0, 0, 0},{0, 0, 0, 0}};
 static swig_cast_info _swigc__p_unsigned_char[] = {  {&_swigt__p_unsigned_char, 0, 0, 0},{0, 0, 0, 0}};
 
 static swig_cast_info *swig_cast_initial[] = {
@@ -6735,13 +9389,19 @@
   _swigc__p_GeosMultiPolygon,
   _swigc__p_GeosPoint,
   _swigc__p_GeosPolygon,
+  _swigc__p_GeosPreparedGeometry,
+  _swigc__p_GeosSTRtree,
   _swigc__p_GeosWkbReader,
   _swigc__p_GeosWkbWriter,
   _swigc__p_GeosWktReader,
   _swigc__p_GeosWktWriter,
   _swigc__p_char,
   _swigc__p_p_GeosLinearRing,
+  _swigc__p_p_void,
   _swigc__p_size_t,
+  _swigc__p_swig__ConstIterator,
+  _swigc__p_swig__GC_VALUE,
+  _swigc__p_swig__Iterator,
   _swigc__p_unsigned_char,
 };
 
@@ -6805,7 +9465,7 @@
 SWIG_InitializeModule(void *clientdata) {
   size_t i;
   swig_module_info *module_head, *iter;
-  int found;
+  int found, init;
 
   clientdata = clientdata;
 
@@ -6815,6 +9475,9 @@
     swig_module.type_initial = swig_type_initial;
     swig_module.cast_initial = swig_cast_initial;
     swig_module.next = &swig_module;
+    init = 1;
+  } else {
+    init = 0;
   }
 
   /* Try and load any already created modules */
@@ -6843,6 +9506,12 @@
     module_head->next = &swig_module;
   }
 
+  /* When multiple interpeters are used, a module could have already been initialized in
+     a different interpreter, but not yet have a pointer in this interpreter.
+     In this case, we do not want to continue adding types... everything should be
+     set up already */
+  if (init == 0) return;
+
   /* Now work on filling in swig_module.types */
 #ifdef SWIGRUNTIME_DEBUG
   printf("SWIG_InitializeModule: size %d\n", swig_module.size);
@@ -6976,7 +9645,9 @@
 }
 #endif
 
+/*
 
+*/
 #ifdef __cplusplus
 extern "C"
 #endif
@@ -6992,16 +9663,59 @@
   }
   
   SWIG_RubyInitializeTrackings();
+  
+  SwigClassGCVALUE.klass = rb_define_class_under(mGeos, "GCVALUE", rb_cObject);
+  SWIG_TypeClientData(SWIGTYPE_p_swig__GC_VALUE, (void *) &SwigClassGCVALUE);
+  rb_undef_alloc_func(SwigClassGCVALUE.klass);
+  rb_define_method(SwigClassGCVALUE.klass, "inspect", VALUEFUNC(_wrap_GCVALUE_inspect), -1);
+  rb_define_method(SwigClassGCVALUE.klass, "to_s", VALUEFUNC(_wrap_GCVALUE_to_s), -1);
+  SwigClassGCVALUE.mark = 0;
+  SwigClassGCVALUE.trackObjects = 0;
+  
+  swig::GC_VALUE::initialize();
+  
+  
+  SwigClassConstIterator.klass = rb_define_class_under(mGeos, "ConstIterator", rb_cObject);
+  SWIG_TypeClientData(SWIGTYPE_p_swig__ConstIterator, (void *) &SwigClassConstIterator);
+  rb_undef_alloc_func(SwigClassConstIterator.klass);
+  rb_define_method(SwigClassConstIterator.klass, "value", VALUEFUNC(_wrap_ConstIterator_value), -1);
+  rb_define_method(SwigClassConstIterator.klass, "dup", VALUEFUNC(_wrap_ConstIterator_dup), -1);
+  rb_define_method(SwigClassConstIterator.klass, "inspect", VALUEFUNC(_wrap_ConstIterator_inspect), -1);
+  rb_define_method(SwigClassConstIterator.klass, "to_s", VALUEFUNC(_wrap_ConstIterator_to_s), -1);
+  rb_define_method(SwigClassConstIterator.klass, "next", VALUEFUNC(_wrap_ConstIterator_next), -1);
+  rb_define_method(SwigClassConstIterator.klass, "previous", VALUEFUNC(_wrap_ConstIterator_previous), -1);
+  rb_define_method(SwigClassConstIterator.klass, "==", VALUEFUNC(_wrap_ConstIterator___eq__), -1);
+  rb_define_method(SwigClassConstIterator.klass, "+", VALUEFUNC(_wrap_ConstIterator___add__), -1);
+  rb_define_method(SwigClassConstIterator.klass, "-", VALUEFUNC(_wrap_ConstIterator___sub__), -1);
+  SwigClassConstIterator.mark = 0;
+  SwigClassConstIterator.destroy = (void (*)(void *)) free_swig_ConstIterator;
+  SwigClassConstIterator.trackObjects = 0;
+  
+  SwigClassIterator.klass = rb_define_class_under(mGeos, "Iterator", ((swig_class *) SWIGTYPE_p_swig__ConstIterator->clientdata)->klass);
+  SWIG_TypeClientData(SWIGTYPE_p_swig__Iterator, (void *) &SwigClassIterator);
+  rb_undef_alloc_func(SwigClassIterator.klass);
+  rb_define_method(SwigClassIterator.klass, "value=", VALUEFUNC(_wrap_Iterator_valuee___), -1);
+  rb_define_method(SwigClassIterator.klass, "dup", VALUEFUNC(_wrap_Iterator_dup), -1);
+  rb_define_method(SwigClassIterator.klass, "next", VALUEFUNC(_wrap_Iterator_next), -1);
+  rb_define_method(SwigClassIterator.klass, "previous", VALUEFUNC(_wrap_Iterator_previous), -1);
+  rb_define_method(SwigClassIterator.klass, "inspect", VALUEFUNC(_wrap_Iterator_inspect), -1);
+  rb_define_method(SwigClassIterator.klass, "to_s", VALUEFUNC(_wrap_Iterator_to_s), -1);
+  rb_define_method(SwigClassIterator.klass, "==", VALUEFUNC(_wrap_Iterator___eq__), -1);
+  rb_define_method(SwigClassIterator.klass, "+", VALUEFUNC(_wrap_Iterator___add__), -1);
+  rb_define_method(SwigClassIterator.klass, "-", VALUEFUNC(_wrap_Iterator___sub__), -1);
+  SwigClassIterator.mark = 0;
+  SwigClassIterator.destroy = (void (*)(void *)) free_swig_Iterator;
+  SwigClassIterator.trackObjects = 0;
   rb_define_const(mGeos, "GEOS_VERSION_MAJOR", SWIG_From_int(static_cast< int >(3)));
-  rb_define_const(mGeos, "GEOS_VERSION_MINOR", SWIG_From_int(static_cast< int >(0)));
-  rb_define_const(mGeos, "GEOS_VERSION", SWIG_FromCharPtr("3.0.0rc4"));
-  rb_define_const(mGeos, "GEOS_JTS_PORT", SWIG_FromCharPtr("1.7.1"));
+  rb_define_const(mGeos, "GEOS_VERSION_MINOR", SWIG_From_int(static_cast< int >(4)));
+  rb_define_const(mGeos, "GEOS_VERSION", SWIG_FromCharPtr("3.4.0dev"));
+  rb_define_const(mGeos, "GEOS_JTS_PORT", SWIG_FromCharPtr("1.12.0"));
   rb_define_const(mGeos, "GEOS_CAPI_VERSION_MAJOR", SWIG_From_int(static_cast< int >(1)));
-  rb_define_const(mGeos, "GEOS_CAPI_VERSION_MINOR", SWIG_From_int(static_cast< int >(3)));
-  rb_define_const(mGeos, "GEOS_CAPI_VERSION_PATCH", SWIG_From_int(static_cast< int >(3)));
+  rb_define_const(mGeos, "GEOS_CAPI_VERSION_MINOR", SWIG_From_int(static_cast< int >(8)));
+  rb_define_const(mGeos, "GEOS_CAPI_VERSION_PATCH", SWIG_From_int(static_cast< int >(0)));
   rb_define_const(mGeos, "GEOS_CAPI_FIRST_INTERFACE", SWIG_From_int(static_cast< int >(1)));
-  rb_define_const(mGeos, "GEOS_CAPI_LAST_INTERFACE", SWIG_From_int(static_cast< int >((1+3))));
-  rb_define_const(mGeos, "GEOS_CAPI_VERSION", SWIG_FromCharPtr("3.0.0rc4-CAPI-1.3.3"));
+  rb_define_const(mGeos, "GEOS_CAPI_LAST_INTERFACE", SWIG_From_int(static_cast< int >((1+8))));
+  rb_define_const(mGeos, "GEOS_CAPI_VERSION", SWIG_FromCharPtr("3.4.0dev-CAPI-1.8.0"));
   rb_define_const(mGeos, "GEOS_POINT", SWIG_From_int(static_cast< int >(GEOS_POINT)));
   rb_define_const(mGeos, "GEOS_LINESTRING", SWIG_From_int(static_cast< int >(GEOS_LINESTRING)));
   rb_define_const(mGeos, "GEOS_LINEARRING", SWIG_From_int(static_cast< int >(GEOS_LINEARRING)));
@@ -7017,190 +9731,214 @@
   
   rb_define_module_function(mGeos, "version", VALUEFUNC(_wrap_version), -1);
   
-  cCoordinateSequence.klass = rb_define_class_under(mGeos, "CoordinateSequence", rb_cObject);
-  SWIG_TypeClientData(SWIGTYPE_p_GeosCoordinateSequence, (void *) &cCoordinateSequence);
-  rb_define_alloc_func(cCoordinateSequence.klass, _wrap_CoordinateSequence_allocate);
-  rb_define_method(cCoordinateSequence.klass, "initialize", VALUEFUNC(_wrap_new_CoordinateSequence), -1);
-  rb_define_method(cCoordinateSequence.klass, "clone", VALUEFUNC(_wrap_CoordinateSequence_clone), -1);
-  rb_define_method(cCoordinateSequence.klass, "set_x", VALUEFUNC(_wrap_CoordinateSequence_set_x), -1);
-  rb_define_method(cCoordinateSequence.klass, "set_y", VALUEFUNC(_wrap_CoordinateSequence_set_y), -1);
-  rb_define_method(cCoordinateSequence.klass, "set_z", VALUEFUNC(_wrap_CoordinateSequence_set_z), -1);
-  rb_define_method(cCoordinateSequence.klass, "set_ordinate", VALUEFUNC(_wrap_CoordinateSequence_set_ordinate), -1);
-  rb_define_method(cCoordinateSequence.klass, "get_x", VALUEFUNC(_wrap_CoordinateSequence_get_x), -1);
-  rb_define_method(cCoordinateSequence.klass, "get_y", VALUEFUNC(_wrap_CoordinateSequence_get_y), -1);
-  rb_define_method(cCoordinateSequence.klass, "get_z", VALUEFUNC(_wrap_CoordinateSequence_get_z), -1);
-  rb_define_method(cCoordinateSequence.klass, "get_ordinate", VALUEFUNC(_wrap_CoordinateSequence_get_ordinate), -1);
-  rb_define_method(cCoordinateSequence.klass, "length", VALUEFUNC(_wrap_CoordinateSequence___len__), -1);
-  rb_define_method(cCoordinateSequence.klass, "dimensions", VALUEFUNC(_wrap_CoordinateSequence_dimensions), -1);
-  cCoordinateSequence.mark = 0;
-  cCoordinateSequence.destroy = (void (*)(void *)) free_GeosCoordinateSequence;
-  cCoordinateSequence.trackObjects = 0;
+  SwigClassCoordinateSequence.klass = rb_define_class_under(mGeos, "CoordinateSequence", rb_cObject);
+  SWIG_TypeClientData(SWIGTYPE_p_GeosCoordinateSequence, (void *) &SwigClassCoordinateSequence);
+  rb_define_alloc_func(SwigClassCoordinateSequence.klass, _wrap_CoordinateSequence_allocate);
+  rb_define_method(SwigClassCoordinateSequence.klass, "initialize", VALUEFUNC(_wrap_new_CoordinateSequence), -1);
+  rb_define_method(SwigClassCoordinateSequence.klass, "clone", VALUEFUNC(_wrap_CoordinateSequence_clone), -1);
+  rb_define_method(SwigClassCoordinateSequence.klass, "set_x", VALUEFUNC(_wrap_CoordinateSequence_set_x), -1);
+  rb_define_method(SwigClassCoordinateSequence.klass, "set_y", VALUEFUNC(_wrap_CoordinateSequence_set_y), -1);
+  rb_define_method(SwigClassCoordinateSequence.klass, "set_z", VALUEFUNC(_wrap_CoordinateSequence_set_z), -1);
+  rb_define_method(SwigClassCoordinateSequence.klass, "set_ordinate", VALUEFUNC(_wrap_CoordinateSequence_set_ordinate), -1);
+  rb_define_method(SwigClassCoordinateSequence.klass, "get_x", VALUEFUNC(_wrap_CoordinateSequence_get_x), -1);
+  rb_define_method(SwigClassCoordinateSequence.klass, "get_y", VALUEFUNC(_wrap_CoordinateSequence_get_y), -1);
+  rb_define_method(SwigClassCoordinateSequence.klass, "get_z", VALUEFUNC(_wrap_CoordinateSequence_get_z), -1);
+  rb_define_method(SwigClassCoordinateSequence.klass, "get_ordinate", VALUEFUNC(_wrap_CoordinateSequence_get_ordinate), -1);
+  rb_define_method(SwigClassCoordinateSequence.klass, "length", VALUEFUNC(_wrap_CoordinateSequence___len__), -1);
+  rb_define_method(SwigClassCoordinateSequence.klass, "dimensions", VALUEFUNC(_wrap_CoordinateSequence_dimensions), -1);
+  SwigClassCoordinateSequence.mark = 0;
+  SwigClassCoordinateSequence.destroy = (void (*)(void *)) free_GeosCoordinateSequence;
+  SwigClassCoordinateSequence.trackObjects = 0;
   
-  cGeometry.klass = rb_define_class_under(mGeos, "Geometry", rb_cObject);
-  SWIG_TypeClientData(SWIGTYPE_p_GeosGeometry, (void *) &cGeometry);
-  rb_undef_alloc_func(cGeometry.klass);
-  rb_define_method(cGeometry.klass, "clone", VALUEFUNC(_wrap_Geometry_clone), -1);
-  rb_define_method(cGeometry.klass, "geom_type", VALUEFUNC(_wrap_Geometry_geom_type), -1);
-  rb_define_method(cGeometry.klass, "type_id", VALUEFUNC(_wrap_Geometry_type_id), -1);
-  rb_define_method(cGeometry.klass, "normalize", VALUEFUNC(_wrap_Geometry_normalize), -1);
-  rb_define_method(cGeometry.klass, "srid", VALUEFUNC(_wrap_Geometry_srid), -1);
-  rb_define_method(cGeometry.klass, "srid=", VALUEFUNC(_wrap_Geometry_sride___), -1);
-  rb_define_method(cGeometry.klass, "dimensions", VALUEFUNC(_wrap_Geometry_dimensions), -1);
-  rb_define_method(cGeometry.klass, "num_geometries", VALUEFUNC(_wrap_Geometry_num_geometries), -1);
-  rb_define_method(cGeometry.klass, "intersection", VALUEFUNC(_wrap_Geometry_intersection), -1);
-  rb_define_method(cGeometry.klass, "buffer", VALUEFUNC(_wrap_Geometry_buffer), -1);
-  rb_define_method(cGeometry.klass, "convex_hull", VALUEFUNC(_wrap_Geometry_convex_hull), -1);
-  rb_define_method(cGeometry.klass, "difference", VALUEFUNC(_wrap_Geometry_difference), -1);
-  rb_define_method(cGeometry.klass, "sym_difference", VALUEFUNC(_wrap_Geometry_sym_difference), -1);
-  rb_define_method(cGeometry.klass, "boundary", VALUEFUNC(_wrap_Geometry_boundary), -1);
-  rb_define_method(cGeometry.klass, "union", VALUEFUNC(_wrap_Geometry_union), -1);
-  rb_define_method(cGeometry.klass, "point_on_surface", VALUEFUNC(_wrap_Geometry_point_on_surface), -1);
-  rb_define_method(cGeometry.klass, "centroid", VALUEFUNC(_wrap_Geometry_centroid), -1);
-  rb_define_alias(cGeometry.klass, "center", "centroid");
-  rb_define_method(cGeometry.klass, "envelope", VALUEFUNC(_wrap_Geometry_envelope), -1);
-  rb_define_method(cGeometry.klass, "relate", VALUEFUNC(_wrap_Geometry_relate), -1);
-  rb_define_method(cGeometry.klass, "line_merge", VALUEFUNC(_wrap_Geometry_line_merge), -1);
-  rb_define_method(cGeometry.klass, "simplify", VALUEFUNC(_wrap_Geometry_simplify), -1);
-  rb_define_method(cGeometry.klass, "topology_preserve_simplify", VALUEFUNC(_wrap_Geometry_topology_preserve_simplify), -1);
-  rb_define_method(cGeometry.klass, "relate_pattern", VALUEFUNC(_wrap_Geometry_relate_pattern), -1);
-  rb_define_method(cGeometry.klass, "disjoint?", VALUEFUNC(_wrap_Geometry_disjointq___), -1);
-  rb_define_method(cGeometry.klass, "touches?", VALUEFUNC(_wrap_Geometry_touchesq___), -1);
-  rb_define_method(cGeometry.klass, "intersects?", VALUEFUNC(_wrap_Geometry_intersectsq___), -1);
-  rb_define_method(cGeometry.klass, "crosses?", VALUEFUNC(_wrap_Geometry_crossesq___), -1);
-  rb_define_method(cGeometry.klass, "within?", VALUEFUNC(_wrap_Geometry_withinq___), -1);
-  rb_define_method(cGeometry.klass, "contains?", VALUEFUNC(_wrap_Geometry_containsq___), -1);
-  rb_define_method(cGeometry.klass, "overlaps?", VALUEFUNC(_wrap_Geometry_overlapsq___), -1);
-  rb_define_method(cGeometry.klass, "eql?", VALUEFUNC(_wrap_Geometry_eqlq___), -1);
-  rb_define_alias(cGeometry.klass, "==", "eql?");
-  rb_define_method(cGeometry.klass, "eql_exact?", VALUEFUNC(_wrap_Geometry_eql_exactq___), -1);
-  rb_define_method(cGeometry.klass, "empty?", VALUEFUNC(_wrap_Geometry_emptyq___), -1);
-  rb_define_method(cGeometry.klass, "valid?", VALUEFUNC(_wrap_Geometry_validq___), -1);
-  rb_define_method(cGeometry.klass, "simple?", VALUEFUNC(_wrap_Geometry_simpleq___), -1);
-  rb_define_method(cGeometry.klass, "ring?", VALUEFUNC(_wrap_Geometry_ringq___), -1);
-  rb_define_method(cGeometry.klass, "has_z?", VALUEFUNC(_wrap_Geometry_has_zq___), -1);
-  rb_define_method(cGeometry.klass, "area", VALUEFUNC(_wrap_Geometry_area), -1);
-  rb_define_method(cGeometry.klass, "length", VALUEFUNC(_wrap_Geometry_length), -1);
-  rb_define_method(cGeometry.klass, "distance", VALUEFUNC(_wrap_Geometry_distance), -1);
-  cGeometry.mark = 0;
-  cGeometry.destroy = (void (*)(void *)) free_GeosGeometry;
-  cGeometry.trackObjects = 0;
+  SwigClassGeometry.klass = rb_define_class_under(mGeos, "Geometry", rb_cObject);
+  SWIG_TypeClientData(SWIGTYPE_p_GeosGeometry, (void *) &SwigClassGeometry);
+  rb_undef_alloc_func(SwigClassGeometry.klass);
+  rb_define_method(SwigClassGeometry.klass, "clone", VALUEFUNC(_wrap_Geometry_clone), -1);
+  rb_define_method(SwigClassGeometry.klass, "geom_type", VALUEFUNC(_wrap_Geometry_geom_type), -1);
+  rb_define_method(SwigClassGeometry.klass, "type_id", VALUEFUNC(_wrap_Geometry_type_id), -1);
+  rb_define_method(SwigClassGeometry.klass, "normalize", VALUEFUNC(_wrap_Geometry_normalize), -1);
+  rb_define_method(SwigClassGeometry.klass, "srid", VALUEFUNC(_wrap_Geometry_srid), -1);
+  rb_define_method(SwigClassGeometry.klass, "srid=", VALUEFUNC(_wrap_Geometry_sride___), -1);
+  rb_define_method(SwigClassGeometry.klass, "dimensions", VALUEFUNC(_wrap_Geometry_dimensions), -1);
+  rb_define_method(SwigClassGeometry.klass, "num_geometries", VALUEFUNC(_wrap_Geometry_num_geometries), -1);
+  rb_define_method(SwigClassGeometry.klass, "intersection", VALUEFUNC(_wrap_Geometry_intersection), -1);
+  rb_define_method(SwigClassGeometry.klass, "buffer", VALUEFUNC(_wrap_Geometry_buffer), -1);
+  rb_define_method(SwigClassGeometry.klass, "convex_hull", VALUEFUNC(_wrap_Geometry_convex_hull), -1);
+  rb_define_method(SwigClassGeometry.klass, "difference", VALUEFUNC(_wrap_Geometry_difference), -1);
+  rb_define_method(SwigClassGeometry.klass, "sym_difference", VALUEFUNC(_wrap_Geometry_sym_difference), -1);
+  rb_define_method(SwigClassGeometry.klass, "boundary", VALUEFUNC(_wrap_Geometry_boundary), -1);
+  rb_define_method(SwigClassGeometry.klass, "union", VALUEFUNC(_wrap_Geometry_union), -1);
+  rb_define_method(SwigClassGeometry.klass, "point_on_surface", VALUEFUNC(_wrap_Geometry_point_on_surface), -1);
+  rb_define_method(SwigClassGeometry.klass, "centroid", VALUEFUNC(_wrap_Geometry_centroid), -1);
+  rb_define_alias(SwigClassGeometry.klass, "center", "centroid");
+  rb_define_method(SwigClassGeometry.klass, "envelope", VALUEFUNC(_wrap_Geometry_envelope), -1);
+  rb_define_method(SwigClassGeometry.klass, "relate", VALUEFUNC(_wrap_Geometry_relate), -1);
+  rb_define_method(SwigClassGeometry.klass, "line_merge", VALUEFUNC(_wrap_Geometry_line_merge), -1);
+  rb_define_method(SwigClassGeometry.klass, "simplify", VALUEFUNC(_wrap_Geometry_simplify), -1);
+  rb_define_method(SwigClassGeometry.klass, "topology_preserve_simplify", VALUEFUNC(_wrap_Geometry_topology_preserve_simplify), -1);
+  rb_define_method(SwigClassGeometry.klass, "relate_pattern", VALUEFUNC(_wrap_Geometry_relate_pattern), -1);
+  rb_define_method(SwigClassGeometry.klass, "disjoint?", VALUEFUNC(_wrap_Geometry_disjointq___), -1);
+  rb_define_method(SwigClassGeometry.klass, "touches?", VALUEFUNC(_wrap_Geometry_touchesq___), -1);
+  rb_define_method(SwigClassGeometry.klass, "intersects?", VALUEFUNC(_wrap_Geometry_intersectsq___), -1);
+  rb_define_method(SwigClassGeometry.klass, "crosses?", VALUEFUNC(_wrap_Geometry_crossesq___), -1);
+  rb_define_method(SwigClassGeometry.klass, "within?", VALUEFUNC(_wrap_Geometry_withinq___), -1);
+  rb_define_method(SwigClassGeometry.klass, "contains?", VALUEFUNC(_wrap_Geometry_containsq___), -1);
+  rb_define_method(SwigClassGeometry.klass, "overlaps?", VALUEFUNC(_wrap_Geometry_overlapsq___), -1);
+  rb_define_method(SwigClassGeometry.klass, "eql?", VALUEFUNC(_wrap_Geometry_eqlq___), -1);
+  rb_define_alias(SwigClassGeometry.klass, "==", "eql?");
+  rb_define_method(SwigClassGeometry.klass, "eql_exact?", VALUEFUNC(_wrap_Geometry_eql_exactq___), -1);
+  rb_define_method(SwigClassGeometry.klass, "empty?", VALUEFUNC(_wrap_Geometry_emptyq___), -1);
+  rb_define_method(SwigClassGeometry.klass, "valid?", VALUEFUNC(_wrap_Geometry_validq___), -1);
+  rb_define_method(SwigClassGeometry.klass, "simple?", VALUEFUNC(_wrap_Geometry_simpleq___), -1);
+  rb_define_method(SwigClassGeometry.klass, "ring?", VALUEFUNC(_wrap_Geometry_ringq___), -1);
+  rb_define_method(SwigClassGeometry.klass, "has_z?", VALUEFUNC(_wrap_Geometry_has_zq___), -1);
+  rb_define_method(SwigClassGeometry.klass, "area", VALUEFUNC(_wrap_Geometry_area), -1);
+  rb_define_method(SwigClassGeometry.klass, "length", VALUEFUNC(_wrap_Geometry_length), -1);
+  rb_define_method(SwigClassGeometry.klass, "distance", VALUEFUNC(_wrap_Geometry_distance), -1);
+  SwigClassGeometry.mark = 0;
+  SwigClassGeometry.destroy = (void (*)(void *)) free_GeosGeometry;
+  SwigClassGeometry.trackObjects = 0;
   
-  cPoint.klass = rb_define_class_under(mGeos, "Point", ((swig_class *) SWIGTYPE_p_GeosGeometry->clientdata)->klass);
-  SWIG_TypeClientData(SWIGTYPE_p_GeosPoint, (void *) &cPoint);
-  rb_undef_alloc_func(cPoint.klass);
-  rb_define_method(cPoint.klass, "coord_seq", VALUEFUNC(_wrap_Point_coord_seq), -1);
-  cPoint.mark = 0;
-  cPoint.destroy = (void (*)(void *)) free_GeosPoint;
-  cPoint.trackObjects = 0;
+  SwigClassPoint.klass = rb_define_class_under(mGeos, "Point", ((swig_class *) SWIGTYPE_p_GeosGeometry->clientdata)->klass);
+  SWIG_TypeClientData(SWIGTYPE_p_GeosPoint, (void *) &SwigClassPoint);
+  rb_undef_alloc_func(SwigClassPoint.klass);
+  rb_define_method(SwigClassPoint.klass, "coord_seq", VALUEFUNC(_wrap_Point_coord_seq), -1);
+  SwigClassPoint.mark = 0;
+  SwigClassPoint.destroy = (void (*)(void *)) free_GeosPoint;
+  SwigClassPoint.trackObjects = 0;
   
-  cLineString.klass = rb_define_class_under(mGeos, "LineString", ((swig_class *) SWIGTYPE_p_GeosGeometry->clientdata)->klass);
-  SWIG_TypeClientData(SWIGTYPE_p_GeosLineString, (void *) &cLineString);
-  rb_undef_alloc_func(cLineString.klass);
-  rb_define_method(cLineString.klass, "coord_seq", VALUEFUNC(_wrap_LineString_coord_seq), -1);
-  cLineString.mark = 0;
-  cLineString.destroy = (void (*)(void *)) free_GeosLineString;
-  cLineString.trackObjects = 0;
+  SwigClassLineString.klass = rb_define_class_under(mGeos, "LineString", ((swig_class *) SWIGTYPE_p_GeosGeometry->clientdata)->klass);
+  SWIG_TypeClientData(SWIGTYPE_p_GeosLineString, (void *) &SwigClassLineString);
+  rb_undef_alloc_func(SwigClassLineString.klass);
+  rb_define_method(SwigClassLineString.klass, "coord_seq", VALUEFUNC(_wrap_LineString_coord_seq), -1);
+  SwigClassLineString.mark = 0;
+  SwigClassLineString.destroy = (void (*)(void *)) free_GeosLineString;
+  SwigClassLineString.trackObjects = 0;
   
-  cLinearRing.klass = rb_define_class_under(mGeos, "LinearRing", ((swig_class *) SWIGTYPE_p_GeosGeometry->clientdata)->klass);
-  SWIG_TypeClientData(SWIGTYPE_p_GeosLinearRing, (void *) &cLinearRing);
-  rb_undef_alloc_func(cLinearRing.klass);
-  rb_define_method(cLinearRing.klass, "coord_seq", VALUEFUNC(_wrap_LinearRing_coord_seq), -1);
-  cLinearRing.mark = 0;
-  cLinearRing.destroy = (void (*)(void *)) free_GeosLinearRing;
-  cLinearRing.trackObjects = 0;
+  SwigClassLinearRing.klass = rb_define_class_under(mGeos, "LinearRing", ((swig_class *) SWIGTYPE_p_GeosGeometry->clientdata)->klass);
+  SWIG_TypeClientData(SWIGTYPE_p_GeosLinearRing, (void *) &SwigClassLinearRing);
+  rb_undef_alloc_func(SwigClassLinearRing.klass);
+  rb_define_method(SwigClassLinearRing.klass, "coord_seq", VALUEFUNC(_wrap_LinearRing_coord_seq), -1);
+  SwigClassLinearRing.mark = 0;
+  SwigClassLinearRing.destroy = (void (*)(void *)) free_GeosLinearRing;
+  SwigClassLinearRing.trackObjects = 0;
   
-  cPolygon.klass = rb_define_class_under(mGeos, "Polygon", ((swig_class *) SWIGTYPE_p_GeosGeometry->clientdata)->klass);
-  SWIG_TypeClientData(SWIGTYPE_p_GeosPolygon, (void *) &cPolygon);
-  rb_undef_alloc_func(cPolygon.klass);
-  rb_define_method(cPolygon.klass, "exterior_ring", VALUEFUNC(_wrap_Polygon_exterior_ring), -1);
-  rb_define_method(cPolygon.klass, "num_interior_rings", VALUEFUNC(_wrap_Polygon_num_interior_rings), -1);
-  rb_define_method(cPolygon.klass, "interior_ring_n", VALUEFUNC(_wrap_Polygon_interior_ring_n), -1);
-  cPolygon.mark = 0;
-  cPolygon.destroy = (void (*)(void *)) free_GeosPolygon;
-  cPolygon.trackObjects = 0;
+  SwigClassPolygon.klass = rb_define_class_under(mGeos, "Polygon", ((swig_class *) SWIGTYPE_p_GeosGeometry->clientdata)->klass);
+  SWIG_TypeClientData(SWIGTYPE_p_GeosPolygon, (void *) &SwigClassPolygon);
+  rb_undef_alloc_func(SwigClassPolygon.klass);
+  rb_define_method(SwigClassPolygon.klass, "exterior_ring", VALUEFUNC(_wrap_Polygon_exterior_ring), -1);
+  rb_define_method(SwigClassPolygon.klass, "num_interior_rings", VALUEFUNC(_wrap_Polygon_num_interior_rings), -1);
+  rb_define_method(SwigClassPolygon.klass, "interior_ring_n", VALUEFUNC(_wrap_Polygon_interior_ring_n), -1);
+  SwigClassPolygon.mark = 0;
+  SwigClassPolygon.destroy = (void (*)(void *)) free_GeosPolygon;
+  SwigClassPolygon.trackObjects = 0;
   
-  cGeometryCollection.klass = rb_define_class_under(mGeos, "GeometryCollection", ((swig_class *) SWIGTYPE_p_GeosGeometry->clientdata)->klass);
-  SWIG_TypeClientData(SWIGTYPE_p_GeosGeometryCollection, (void *) &cGeometryCollection);
-  rb_undef_alloc_func(cGeometryCollection.klass);
-  rb_define_method(cGeometryCollection.klass, "get_geometry_n", VALUEFUNC(_wrap_GeometryCollection_get_geometry_n), -1);
-  cGeometryCollection.mark = 0;
-  cGeometryCollection.destroy = (void (*)(void *)) free_GeosGeometryCollection;
-  cGeometryCollection.trackObjects = 0;
+  SwigClassGeometryCollection.klass = rb_define_class_under(mGeos, "GeometryCollection", ((swig_class *) SWIGTYPE_p_GeosGeometry->clientdata)->klass);
+  SWIG_TypeClientData(SWIGTYPE_p_GeosGeometryCollection, (void *) &SwigClassGeometryCollection);
+  rb_undef_alloc_func(SwigClassGeometryCollection.klass);
+  rb_define_method(SwigClassGeometryCollection.klass, "get_geometry_n", VALUEFUNC(_wrap_GeometryCollection_get_geometry_n), -1);
+  SwigClassGeometryCollection.mark = 0;
+  SwigClassGeometryCollection.destroy = (void (*)(void *)) free_GeosGeometryCollection;
+  SwigClassGeometryCollection.trackObjects = 0;
   
-  cMultiPoint.klass = rb_define_class_under(mGeos, "MultiPoint", ((swig_class *) SWIGTYPE_p_GeosGeometryCollection->clientdata)->klass);
-  SWIG_TypeClientData(SWIGTYPE_p_GeosMultiPoint, (void *) &cMultiPoint);
-  rb_undef_alloc_func(cMultiPoint.klass);
-  cMultiPoint.mark = 0;
-  cMultiPoint.destroy = (void (*)(void *)) free_GeosMultiPoint;
-  cMultiPoint.trackObjects = 0;
+  SwigClassMultiPoint.klass = rb_define_class_under(mGeos, "MultiPoint", ((swig_class *) SWIGTYPE_p_GeosGeometryCollection->clientdata)->klass);
+  SWIG_TypeClientData(SWIGTYPE_p_GeosMultiPoint, (void *) &SwigClassMultiPoint);
+  rb_undef_alloc_func(SwigClassMultiPoint.klass);
+  SwigClassMultiPoint.mark = 0;
+  SwigClassMultiPoint.destroy = (void (*)(void *)) free_GeosMultiPoint;
+  SwigClassMultiPoint.trackObjects = 0;
   
-  cMultiLineString.klass = rb_define_class_under(mGeos, "MultiLineString", ((swig_class *) SWIGTYPE_p_GeosGeometryCollection->clientdata)->klass);
-  SWIG_TypeClientData(SWIGTYPE_p_GeosMultiLineString, (void *) &cMultiLineString);
-  rb_undef_alloc_func(cMultiLineString.klass);
-  cMultiLineString.mark = 0;
-  cMultiLineString.destroy = (void (*)(void *)) free_GeosMultiLineString;
-  cMultiLineString.trackObjects = 0;
+  SwigClassMultiLineString.klass = rb_define_class_under(mGeos, "MultiLineString", ((swig_class *) SWIGTYPE_p_GeosGeometryCollection->clientdata)->klass);
+  SWIG_TypeClientData(SWIGTYPE_p_GeosMultiLineString, (void *) &SwigClassMultiLineString);
+  rb_undef_alloc_func(SwigClassMultiLineString.klass);
+  SwigClassMultiLineString.mark = 0;
+  SwigClassMultiLineString.destroy = (void (*)(void *)) free_GeosMultiLineString;
+  SwigClassMultiLineString.trackObjects = 0;
   
-  cMultiLinearRing.klass = rb_define_class_under(mGeos, "MultiLinearRing", ((swig_class *) SWIGTYPE_p_GeosGeometryCollection->clientdata)->klass);
-  SWIG_TypeClientData(SWIGTYPE_p_GeosMultiLinearRing, (void *) &cMultiLinearRing);
-  rb_undef_alloc_func(cMultiLinearRing.klass);
-  cMultiLinearRing.mark = 0;
-  cMultiLinearRing.destroy = (void (*)(void *)) free_GeosMultiLinearRing;
-  cMultiLinearRing.trackObjects = 0;
+  SwigClassMultiLinearRing.klass = rb_define_class_under(mGeos, "MultiLinearRing", ((swig_class *) SWIGTYPE_p_GeosGeometryCollection->clientdata)->klass);
+  SWIG_TypeClientData(SWIGTYPE_p_GeosMultiLinearRing, (void *) &SwigClassMultiLinearRing);
+  rb_undef_alloc_func(SwigClassMultiLinearRing.klass);
+  SwigClassMultiLinearRing.mark = 0;
+  SwigClassMultiLinearRing.destroy = (void (*)(void *)) free_GeosMultiLinearRing;
+  SwigClassMultiLinearRing.trackObjects = 0;
   
-  cMultiPolygon.klass = rb_define_class_under(mGeos, "MultiPolygon", ((swig_class *) SWIGTYPE_p_GeosGeometryCollection->clientdata)->klass);
-  SWIG_TypeClientData(SWIGTYPE_p_GeosMultiPolygon, (void *) &cMultiPolygon);
-  rb_undef_alloc_func(cMultiPolygon.klass);
-  cMultiPolygon.mark = 0;
-  cMultiPolygon.destroy = (void (*)(void *)) free_GeosMultiPolygon;
-  cMultiPolygon.trackObjects = 0;
+  SwigClassMultiPolygon.klass = rb_define_class_under(mGeos, "MultiPolygon", ((swig_class *) SWIGTYPE_p_GeosGeometryCollection->clientdata)->klass);
+  SWIG_TypeClientData(SWIGTYPE_p_GeosMultiPolygon, (void *) &SwigClassMultiPolygon);
+  rb_undef_alloc_func(SwigClassMultiPolygon.klass);
+  SwigClassMultiPolygon.mark = 0;
+  SwigClassMultiPolygon.destroy = (void (*)(void *)) free_GeosMultiPolygon;
+  SwigClassMultiPolygon.trackObjects = 0;
   rb_define_module_function(mGeos, "create_point", VALUEFUNC(_wrap_create_point), -1);
   rb_define_module_function(mGeos, "create_line_string", VALUEFUNC(_wrap_create_line_string), -1);
   rb_define_module_function(mGeos, "create_linear_ring", VALUEFUNC(_wrap_create_linear_ring), -1);
   rb_define_module_function(mGeos, "create_polygon", VALUEFUNC(_wrap_create_polygon), -1);
   
-  cWktReader.klass = rb_define_class_under(mGeos, "WktReader", rb_cObject);
-  SWIG_TypeClientData(SWIGTYPE_p_GeosWktReader, (void *) &cWktReader);
-  rb_define_alloc_func(cWktReader.klass, _wrap_WktReader_allocate);
-  rb_define_method(cWktReader.klass, "initialize", VALUEFUNC(_wrap_new_WktReader), -1);
-  rb_define_method(cWktReader.klass, "read", VALUEFUNC(_wrap_WktReader_read), -1);
-  cWktReader.mark = 0;
-  cWktReader.destroy = (void (*)(void *)) free_GeosWktReader;
-  cWktReader.trackObjects = 0;
+  SwigClassPrepared.klass = rb_define_class_under(mGeos, "Prepared", rb_cObject);
+  SWIG_TypeClientData(SWIGTYPE_p_GeosPreparedGeometry, (void *) &SwigClassPrepared);
+  rb_define_alloc_func(SwigClassPrepared.klass, _wrap_Prepared_allocate);
+  rb_define_method(SwigClassPrepared.klass, "initialize", VALUEFUNC(_wrap_new_Prepared), -1);
+  rb_define_method(SwigClassPrepared.klass, "contains?", VALUEFUNC(_wrap_Prepared_containsq___), -1);
+  rb_define_method(SwigClassPrepared.klass, "contains_properly?", VALUEFUNC(_wrap_Prepared_contains_properlyq___), -1);
+  rb_define_method(SwigClassPrepared.klass, "covers?", VALUEFUNC(_wrap_Prepared_coversq___), -1);
+  rb_define_method(SwigClassPrepared.klass, "intersects?", VALUEFUNC(_wrap_Prepared_intersectsq___), -1);
+  SwigClassPrepared.mark = 0;
+  SwigClassPrepared.destroy = (void (*)(void *)) free_GeosPreparedGeometry;
+  SwigClassPrepared.trackObjects = 0;
   
-  cWktWriter.klass = rb_define_class_under(mGeos, "WktWriter", rb_cObject);
-  SWIG_TypeClientData(SWIGTYPE_p_GeosWktWriter, (void *) &cWktWriter);
-  rb_define_alloc_func(cWktWriter.klass, _wrap_WktWriter_allocate);
-  rb_define_method(cWktWriter.klass, "initialize", VALUEFUNC(_wrap_new_WktWriter), -1);
-  rb_define_method(cWktWriter.klass, "write", VALUEFUNC(_wrap_WktWriter_write), -1);
-  cWktWriter.mark = 0;
-  cWktWriter.destroy = (void (*)(void *)) free_GeosWktWriter;
-  cWktWriter.trackObjects = 0;
+  SwigClassSTRtree.klass = rb_define_class_under(mGeos, "STRtree", rb_cObject);
+  SWIG_TypeClientData(SWIGTYPE_p_GeosSTRtree, (void *) &SwigClassSTRtree);
+  rb_define_alloc_func(SwigClassSTRtree.klass, _wrap_STRtree_allocate);
+  rb_define_method(SwigClassSTRtree.klass, "initialize", VALUEFUNC(_wrap_new_STRtree), -1);
+  rb_define_method(SwigClassSTRtree.klass, "insert", VALUEFUNC(_wrap_STRtree_insert), -1);
+  rb_define_method(SwigClassSTRtree.klass, "remove", VALUEFUNC(_wrap_STRtree_remove), -1);
+  rb_define_method(SwigClassSTRtree.klass, "query", VALUEFUNC(_wrap_STRtree_query), -1);
+  rb_define_method(SwigClassSTRtree.klass, "each", VALUEFUNC(_wrap_STRtree_each), -1);
+  SwigClassSTRtree.mark = (void (*)(void *)) mark_GeosSTRtree;
+  SwigClassSTRtree.destroy = (void (*)(void *)) free_GeosSTRtree;
+  SwigClassSTRtree.trackObjects = 0;
   
-  cWkbReader.klass = rb_define_class_under(mGeos, "WkbReader", rb_cObject);
-  SWIG_TypeClientData(SWIGTYPE_p_GeosWkbReader, (void *) &cWkbReader);
-  rb_define_alloc_func(cWkbReader.klass, _wrap_WkbReader_allocate);
-  rb_define_method(cWkbReader.klass, "initialize", VALUEFUNC(_wrap_new_WkbReader), -1);
-  rb_define_method(cWkbReader.klass, "read", VALUEFUNC(_wrap_WkbReader_read), -1);
-  rb_define_method(cWkbReader.klass, "read_hex", VALUEFUNC(_wrap_WkbReader_read_hex), -1);
-  cWkbReader.mark = 0;
-  cWkbReader.destroy = (void (*)(void *)) free_GeosWkbReader;
-  cWkbReader.trackObjects = 0;
+  SwigClassWktReader.klass = rb_define_class_under(mGeos, "WktReader", rb_cObject);
+  SWIG_TypeClientData(SWIGTYPE_p_GeosWktReader, (void *) &SwigClassWktReader);
+  rb_define_alloc_func(SwigClassWktReader.klass, _wrap_WktReader_allocate);
+  rb_define_method(SwigClassWktReader.klass, "initialize", VALUEFUNC(_wrap_new_WktReader), -1);
+  rb_define_method(SwigClassWktReader.klass, "read", VALUEFUNC(_wrap_WktReader_read), -1);
+  SwigClassWktReader.mark = 0;
+  SwigClassWktReader.destroy = (void (*)(void *)) free_GeosWktReader;
+  SwigClassWktReader.trackObjects = 0;
   
-  cWkbWriter.klass = rb_define_class_under(mGeos, "WkbWriter", rb_cObject);
-  SWIG_TypeClientData(SWIGTYPE_p_GeosWkbWriter, (void *) &cWkbWriter);
-  rb_define_alloc_func(cWkbWriter.klass, _wrap_WkbWriter_allocate);
-  rb_define_method(cWkbWriter.klass, "initialize", VALUEFUNC(_wrap_new_WkbWriter), -1);
-  rb_define_method(cWkbWriter.klass, "output_dimensions", VALUEFUNC(_wrap_WkbWriter_output_dimensions), -1);
-  rb_define_method(cWkbWriter.klass, "output_dimensions=", VALUEFUNC(_wrap_WkbWriter_output_dimensionse___), -1);
-  rb_define_method(cWkbWriter.klass, "byte_order", VALUEFUNC(_wrap_WkbWriter_byte_order), -1);
-  rb_define_method(cWkbWriter.klass, "byte_order=", VALUEFUNC(_wrap_WkbWriter_byte_ordere___), -1);
-  rb_define_method(cWkbWriter.klass, "include_srid", VALUEFUNC(_wrap_WkbWriter_include_srid), -1);
-  rb_define_method(cWkbWriter.klass, "include_srid=", VALUEFUNC(_wrap_WkbWriter_include_sride___), -1);
-  rb_define_method(cWkbWriter.klass, "write", VALUEFUNC(_wrap_WkbWriter_write), -1);
-  rb_define_method(cWkbWriter.klass, "write_hex", VALUEFUNC(_wrap_WkbWriter_write_hex), -1);
-  cWkbWriter.mark = 0;
-  cWkbWriter.destroy = (void (*)(void *)) free_GeosWkbWriter;
-  cWkbWriter.trackObjects = 0;
+  SwigClassWktWriter.klass = rb_define_class_under(mGeos, "WktWriter", rb_cObject);
+  SWIG_TypeClientData(SWIGTYPE_p_GeosWktWriter, (void *) &SwigClassWktWriter);
+  rb_define_alloc_func(SwigClassWktWriter.klass, _wrap_WktWriter_allocate);
+  rb_define_method(SwigClassWktWriter.klass, "initialize", VALUEFUNC(_wrap_new_WktWriter), -1);
+  rb_define_method(SwigClassWktWriter.klass, "write", VALUEFUNC(_wrap_WktWriter_write), -1);
+  SwigClassWktWriter.mark = 0;
+  SwigClassWktWriter.destroy = (void (*)(void *)) free_GeosWktWriter;
+  SwigClassWktWriter.trackObjects = 0;
+  
+  SwigClassWkbReader.klass = rb_define_class_under(mGeos, "WkbReader", rb_cObject);
+  SWIG_TypeClientData(SWIGTYPE_p_GeosWkbReader, (void *) &SwigClassWkbReader);
+  rb_define_alloc_func(SwigClassWkbReader.klass, _wrap_WkbReader_allocate);
+  rb_define_method(SwigClassWkbReader.klass, "initialize", VALUEFUNC(_wrap_new_WkbReader), -1);
+  rb_define_method(SwigClassWkbReader.klass, "read", VALUEFUNC(_wrap_WkbReader_read), -1);
+  rb_define_method(SwigClassWkbReader.klass, "read_hex", VALUEFUNC(_wrap_WkbReader_read_hex), -1);
+  SwigClassWkbReader.mark = 0;
+  SwigClassWkbReader.destroy = (void (*)(void *)) free_GeosWkbReader;
+  SwigClassWkbReader.trackObjects = 0;
+  
+  SwigClassWkbWriter.klass = rb_define_class_under(mGeos, "WkbWriter", rb_cObject);
+  SWIG_TypeClientData(SWIGTYPE_p_GeosWkbWriter, (void *) &SwigClassWkbWriter);
+  rb_define_alloc_func(SwigClassWkbWriter.klass, _wrap_WkbWriter_allocate);
+  rb_define_method(SwigClassWkbWriter.klass, "initialize", VALUEFUNC(_wrap_new_WkbWriter), -1);
+  rb_define_method(SwigClassWkbWriter.klass, "output_dimensions", VALUEFUNC(_wrap_WkbWriter_output_dimensions), -1);
+  rb_define_method(SwigClassWkbWriter.klass, "output_dimensions=", VALUEFUNC(_wrap_WkbWriter_output_dimensionse___), -1);
+  rb_define_method(SwigClassWkbWriter.klass, "byte_order", VALUEFUNC(_wrap_WkbWriter_byte_order), -1);
+  rb_define_method(SwigClassWkbWriter.klass, "byte_order=", VALUEFUNC(_wrap_WkbWriter_byte_ordere___), -1);
+  rb_define_method(SwigClassWkbWriter.klass, "include_srid", VALUEFUNC(_wrap_WkbWriter_include_srid), -1);
+  rb_define_method(SwigClassWkbWriter.klass, "include_srid=", VALUEFUNC(_wrap_WkbWriter_include_sride___), -1);
+  rb_define_method(SwigClassWkbWriter.klass, "write", VALUEFUNC(_wrap_WkbWriter_write), -1);
+  rb_define_method(SwigClassWkbWriter.klass, "write_hex", VALUEFUNC(_wrap_WkbWriter_write_hex), -1);
+  SwigClassWkbWriter.mark = 0;
+  SwigClassWkbWriter.destroy = (void (*)(void *)) free_GeosWkbWriter;
+  SwigClassWkbWriter.trackObjects = 0;
 }
 
diff --ignore-all-space -urNad geos-3.3.9-orig/swig/ruby/ruby.i geos-3.3.9/swig/ruby/ruby.i
--- geos-3.3.9-orig/swig/ruby/ruby.i	2009-07-15 21:56:30.000000000 +0300
+++ geos-3.3.9/swig/ruby/ruby.i	2015-04-26 12:22:40.000000000 +0300
@@ -75,7 +75,7 @@
         Check_Type($input, T_ARRAY);
 
         /* Get the length */
-        $2 = RARRAY($input)->len;
+        $2 = RARRAY_LEN($input);
       
         /* Allocate space for the C array. */
         $1 = (GeosLinearRing**) malloc($2*sizeof(GeosLinearRing*));
